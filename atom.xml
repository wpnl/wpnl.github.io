<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>烫烫烫的锟斤拷哒~</title>
  <icon>https://www.gravatar.com/avatar/9821c5879313d50dd8d5530069a6fa91</icon>
  <subtitle>0xEFBF0xBDEF0xBDEF</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-16T07:10:08.720Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Fwfeng</name>
    <email>532118819@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React Hooks 详解</title>
    <link href="http://yoursite.com/2020/02/react-hooks/"/>
    <id>http://yoursite.com/2020/02/react-hooks/</id>
    <published>2020-02-16T07:04:00.000Z</published>
    <updated>2020-02-16T07:10:08.720Z</updated>
    
    <content type="html"><![CDATA[<p><strong>React hooks</strong> 是<strong>react16.8</strong>版本的新特性，主要用来解决类组件的不足和函数组件没有生命周期没有状态带来的问题。</p><a id="more"></a><h1 id="Hooks的特性"><a href="#Hooks的特性" class="headerlink" title="Hooks的特性"></a>Hooks的特性</h1><ul><li>React Hooks可以让我们不编写calss的情况下使用state以及React的特性（生命周期）。</li><li>React 的思想一致都是建议使用<strong>函数组件</strong>，但是很多时候我们需要使用state和一些生命周期，hooks就是用来解决这样的问题。</li><li>凡是use开头的React API都是Hooks。</li><li>Hook可以有效的解决状态逻辑难以复用、this指向问题、生命周期混杂的逻辑。</li></ul><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><h2 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, setState] = useState(state)</span><br></pre></td></tr></table></figure><ul><li>useState 接受一个参数state，代表数据的初始值</li><li>useState 会返回一个数组，一个为state，另一个为更新state的函数</li><li>setState方法可接受一个函数或者要更新的值。</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getCount</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> props.count</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(getCount)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">      Click me</span></span><br><span class="line"><span class="regexp">       &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">   );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Example</span></span><br></pre></td></tr></table></figure><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><strong>每次渲染都是独立的闭包</strong>：当点击更新状态的时候，函数组件都会重新被调用，那么每次渲染都是独立的，取到的值不会受后面操作的影响。</p><p><strong>惰性初始化 state</strong>：如果初始 state 需要通过复杂计算获得，则可以传入一个函数，在函数中计算并返回初始的 state，此函数只在初始渲染时被调用。</p><h2 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h2><p>useMemo会在组件第一次渲染时候执行一次，返回第一个参数函数的返回值。之后会在其依赖的变量发生改变时再次执行，也就是说useMemo只会在其中一个依赖项发生更改时重新计算memoizedValue的值。此优化有助于避免在每个渲染上进行昂贵的计算。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedValue = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> computeExpensiveValue(a, b), [a, b])</span><br></pre></td></tr></table></figure><p>用法</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useMemo &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ExampleA = <span class="function">(<span class="params">&#123;text&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;ExampleA&lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ExampleB = <span class="function">(<span class="params">&#123;text&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;ExampleB&lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [a, setA] = useState(<span class="string">'a'</span>)</span><br><span class="line">  <span class="keyword">const</span> [b, setB] = useState(<span class="string">'b'</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> exampleA = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &lt;ExampleA text=&#123;a&#125; /&gt;, [a])</span><br><span class="line">  const exampleB = useMemo(() =&gt; &lt;ExampleB text=&#123;b&#125; /&gt;, [b])</span><br><span class="line">  </span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    &#123; exampleA &#125;</span><br><span class="line">      &#123; exampleB &#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setA('aa')&#125;&gt;修改a的值，只会重新渲染exampleA组件&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; setA('bb')&#125;&gt;修改b的值，只会重新渲染exampleB组件&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，如果我们不使用useMemo，当我修改a的时候，exampleB组件也会触发更新，这是非常没有必要的，所以我们可以利用useMemo的特性，之后在其依赖发生变化时才重新触发更新，这对一直值的改变也可以生效。</p><h2 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h2><p>useCallback跟useMemo比较类似，但它返回的是缓存的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个fn函数会被缓存，只有当依赖发生变化时，fn函数才会重新去定义。</span></span><br><span class="line"><span class="comment">// 这样不用每次重新声明新的函数，避免释放内存、分配内存的计算资源浪费</span></span><br><span class="line"><span class="keyword">const</span> fn = useCallback(expensiveFn, [a])</span><br></pre></td></tr></table></figure><h2 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h2><ul><li>useReducer 和 redux 中 reducer 很像</li><li>useState 的代替方案，接受类型为 <code>(state, action) =&gt; newState 的reducer</code>，并返回与 <code>dispatch</code> 方法配对的当前状态。</li><li>函数的第三个参数是一个函数，可以理解为用来进行复杂的计算，然后返回最终的initialState。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState, initFn)</span><br></pre></td></tr></table></figure><p>用法</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useReducer &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;<span class="attr">number</span>: <span class="number">0</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'increment'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">number</span>: state.number + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'decrement'</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">number</span>: state.number - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">initialCount</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 可以动态添加一个属性</span></span><br><span class="line">  <span class="keyword">return</span> &#123;...initialCount, <span class="attr">count</span>: <span class="number">0</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState, init);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      Count: &#123;state.number&#125;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123;<span class="attr">type</span>: <span class="string">'increment'</span>&#125;)&#125;&gt;+&lt;/button&gt;</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; dispatch(&#123;<span class="attr">type</span>: <span class="string">'decrement'</span>&#125;)&#125;&gt;-&lt;/button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = useContext(MyContext)</span><br></pre></td></tr></table></figure><p>接受上下文对象（从中React.createContext返回的值）并返回该上下文的当前上下文值。当前上下文值由树中调用组件上方value最近的prop 确定&lt;MyContext.Provider&gt;。</p><p>用法</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; createContext, useContext &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Example <span class="keyword">from</span> <span class="string">'./Example'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ThemeContext = createContext();</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;ThemeContext.Provider value=<span class="string">"light"</span>&gt;</span><br><span class="line">            &lt;Example /&gt;</span><br><span class="line">        &lt;<span class="regexp">/ThemeContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ Example.js</span></span><br><span class="line"><span class="regexp">function Example () &#123;</span></span><br><span class="line"><span class="regexp">  const context = useContext(ThemeContext)</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;Example 组件：当前 theme 是：&#123; context &#125;&lt;/</span>div&gt;   </span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><p>当我们的函数具有副作用的操作，例如ajax，一般都是在 <code>class</code> 组件的 <code>componentDidMount</code> 或者 <code>componentDidUpdate</code> 等生命周期中进行操作。而在函数组件中是没有这些生命周期的概念的，只能 <code>return</code> 想要渲染的元素。 但是现在，在函数组件中也有执行副作用操作的地方了，就是使用 <code>useEffect</code> 函数。</p><p>该函数接受两个参数</p><ul><li><strong>第一个参数</strong>：是一个函数，会第一次渲染以及之后更新渲染之后会进行的副作用。<strong>这个函数如果有返回值，回值也必须是一个函数，会在组件被销毁时执行。</strong></li><li><strong>第二个参数</strong>：是一个可选的数组，代表触发副作用依赖的属性。<ul><li>如果要使 effect 并仅将其清理一次，则可以将空数组（[]）作为第二个参数传递。这代表effect 不依赖于来自 props 或 state 的任何值，所以它永远不需要重新运行。</li></ul></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类似于 componentDidMount 和 componentDidUpdate生命周期</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span></span><br><span class="line">  &#125;, [count]) <span class="comment">// 数组表示 effect 依赖的变量，只有当这个变量发生改变之后才会重新执行 efffect 函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click me</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>当我们函数返回一个函数时，就是说想要在<code>componentWillMount</code>生命周期去进行事件的移除</p><blockquote><p><strong>Hook 允许我们按照代码的用途分离他们，</strong> 而不是像生命周期函数那样。React 将按照 effect 声明的顺序依次调用组件中的 每一个 effect。</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'鼠标点击'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类似于 componentDidMount 和 componentDidUpdate生命周期</span></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span></span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'click'</span>, handleClick)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">'click'</span>, handleClick)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">        Click me</span></span><br><span class="line"><span class="regexp">      &lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h2><p>与 <code>useEffect</code> Hooks 类似，都是执行副作用操作。但是它是在所有 DOM 更新完成后触发。可以用来执行一些与布局相关的副作用，比如获取 DOM 元素宽高，窗口滚动距离等等。</p><ul><li><strong>useEffect 在全部渲染完毕后才会执行</strong></li><li><strong>useLayoutEffect 会在 浏览器 layout 之后，painting 之前执行</strong></li><li><strong>可以使用它来读取 DOM 布局并同步触发重渲染</strong></li><li><strong>尽可能使用标准的 useEffect 以避免阻塞视图更新</strong></li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useLayoutEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [width, setWidth] = useState(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  useLayoutEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// DOM 更新完成后打印出 div 的高度</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'useLayoutEffect: '</span>, width)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div style=&#123;&#123; width, <span class="attr">background</span>: <span class="string">'#000'</span> &#125;&#125;&gt;Hello&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123; () =&gt; setWidth(width + 50) &#125;&gt;改变 div 宽度&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> refContainer = useRef(initialValue)</span><br></pre></td></tr></table></figure><p>useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传递的参数（initialValue）。返回的对象将存留在整个组件的生命周期中。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useRef &#125; <span class="keyword">from</span> <span class="string">'react'</span>; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = useRef()</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getFocus</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    inputRef.current.focus()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input type=<span class="string">"text"</span> ref=&#123;inputRef&#125; /&gt;</span><br><span class="line">      &lt;button onClick=&#123;getFocus&#125;&gt;获得焦点&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="自定义Hooks"><a href="#自定义Hooks" class="headerlink" title="自定义Hooks"></a>自定义Hooks</h1><p>自定义 Hook 是一种约定，而不是一种功能。如果函数的名字以 use 开头，并且调用了其他的 Hook，则就称其为一个自定义 Hook。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useReducer</span>(<span class="params">reducer, initialState</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = useState(initialState);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> nextState = reducer(state, action);</span><br><span class="line">    setState(nextState);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> [state, dispatch];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener">React 官网</a></p><p><a href="https://reactjs.org/docs/hooks-faq.html" target="_blank" rel="noopener">React Hooks FAQ</a></p><p><a href="https://juejin.im/post/5d9c5f935188251e3a06bbbb" target="_blank" rel="noopener">React Hooks 你真的用对了吗？</a></p><p><a href="https://github.com/streamich/react-use" target="_blank" rel="noopener">大量自定义 hooks 的</a><a href="https://github.com/streamich/react-use" target="_blank" rel="noopener">仓库</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;React hooks&lt;/strong&gt; 是&lt;strong&gt;react16.8&lt;/strong&gt;版本的新特性，主要用来解决类组件的不足和函数组件没有生命周期没有状态带来的问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>实现一个mini的vue</title>
    <link href="http://yoursite.com/2020/01/vue-mvvm/"/>
    <id>http://yoursite.com/2020/01/vue-mvvm/</id>
    <published>2020-01-22T12:56:00.000Z</published>
    <updated>2020-01-31T12:40:31.600Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习vue源码，不断的反复阅读，终于明白vue的核心，是如何收集依赖，触发更新的。下面根据vue的思想，自己实现一个mini版的vue，巩固知识。</p><a id="more"></a><p>我们常说：vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p><p>那么到底如何实现，我们先看看vue的核心流程，如图：</p><p><img src="/assets/images/vue.png" alt></p><p>简单总结</p><ul><li>Object.defineProperty劫持data的属性。</li><li>vue编译模板生成render函数，render函数获取data.xx，触发get，把render watcher收集到依赖里。</li><li>当我们set修改数据时，就会通知依赖去更新。</li></ul><h1 id="核心分析"><a href="#核心分析" class="headerlink" title="核心分析"></a>核心分析</h1><p>首先我们要知道双向绑定的几个核心东西</p><ul><li>Observe</li><li>Dep</li><li>Compile</li><li>Watcher</li></ul><p>Observe用来把data变成响应式</p><p>Dep是依赖管理器，每一个data属性都有一个dep来管理他们的依赖</p><p>Watcher本质上就是我们所说的依赖。</p><p>Compile函数用来编译模板，触发依赖收集</p><p>假设我们有下面这样的数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">my-text</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"changeName"</span>&gt;</span>点我我就变给你看<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">my-html</span>=<span class="string">"html"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">  const myVue = new MyVue(&#123;</span><br><span class="line">      el: 'app',</span><br><span class="line">      data: &#123;</span><br><span class="line">        name: "我是一个mini的vue",</span><br><span class="line"><span class="xml">        html: '<span class="tag">&lt;<span class="name">h2</span>&gt;</span>这是一个加粗的h2标签<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        changeName() &#123;</span><br><span class="line">          this.name = '你看我变了吧'</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来我们一步一步来实现吧~</p><h2 id="实现MyVue"><a href="#实现MyVue" class="headerlink" title="实现MyVue"></a>实现MyVue</h2><ul><li>首先我们要编写一个MyVue构造函数，有以下功能：<ol><li>实现Observe把data变成响应式的，</li><li>实现proxyData函数把this.xx代理到this.data.xx</li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyVue.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyVue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$options = options</span><br><span class="line">    <span class="keyword">this</span>.$data = options.data</span><br><span class="line">    <span class="comment">// 响应化处理</span></span><br><span class="line">    <span class="keyword">this</span>.observe(<span class="keyword">this</span>.$data)</span><br><span class="line">  &#125;</span><br><span class="line">  observe(value) &#123;</span><br><span class="line">    <span class="comment">// 因为要递归调用，如果不是对象会返回</span></span><br><span class="line">    <span class="keyword">if</span> (!value || <span class="keyword">typeof</span> value !== <span class="string">'object'</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(value).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.defineReactive(value, key, value[key])</span><br><span class="line">      <span class="comment">// 把this.xx代理到this.data.xx</span></span><br><span class="line">      <span class="keyword">this</span>.proxyData(key)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 劫持对象</span></span><br><span class="line">  defineReactive(obj, key, val) &#123;</span><br><span class="line">    <span class="comment">// 每一个属性都有一个dep，用作管理依赖</span></span><br><span class="line">    <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">      <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="comment">// 收集依赖</span></span><br><span class="line">        Dep.target &amp;&amp; dep.addDep(Dep.target)</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span>(newVal) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newVal !== val) &#123;</span><br><span class="line">          val = newVal</span><br><span class="line">          dep.notify()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 递归收集依赖</span></span><br><span class="line">    <span class="keyword">this</span>.observe(val)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 数据代理</span></span><br><span class="line">  proxyData(key) &#123;</span><br><span class="line">    <span class="comment">// 当获取this.xx，则返回this.$data.xx</span></span><br><span class="line">    <span class="comment">// 当修改this.xx，则修改this.$data.xx</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, key, &#123;</span><br><span class="line">      <span class="keyword">get</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$data[key]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span>(newVal)&#123;</span><br><span class="line">        <span class="keyword">this</span>.$data[key] = newVal</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码不难理解，关键是收集依赖这一步，这时候我们要实现一个Dep</p><h2 id="实现Dep"><a href="#实现Dep" class="headerlink" title="实现Dep"></a>实现Dep</h2><p>Dep依赖管理器很简单，从上面可以看出它只有addDep添加依赖和notify通知依赖更新两个方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Dep</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="comment">// 一个属性可以有多个依赖</span></span><br><span class="line">    <span class="keyword">this</span>.deps = []</span><br><span class="line">  &#125;</span><br><span class="line">  addDep(dep) &#123;</span><br><span class="line">    <span class="keyword">this</span>.deps.push(dep)</span><br><span class="line">  &#125;</span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="keyword">this</span>.deps.forEach(<span class="function"><span class="params">dep</span> =&gt;</span> dep.update())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个不理解可以先不用管</span></span><br><span class="line">Dep.target = <span class="literal">null</span></span><br></pre></td></tr></table></figure><h2 id="实现Watcher"><a href="#实现Watcher" class="headerlink" title="实现Watcher"></a>实现Watcher</h2><p>接下来我们来实现Watcher</p><p>Watcher（订阅者）本质上就是依赖，在上面的例子里，依赖就是模板中的那些标签。也就是说<code>&lt;p&gt;&lt;/p&gt;</code>这个标签可以理解为是name属性的依赖，当我们去修改name时，去通知这个依赖重新渲染。</p><p>现在回到应该如何触发收集依赖，在上面的例子里，我们收集依赖是在get里实现，所有我们Watcher要主动去获取这个属性，这样依赖就被收集了</p><p>Watcher本质上就是依赖，在上面的例子里，依赖就是模板中的那些标签。也就是说，<code>&lt;p&gt;&lt;/p&gt;</code>这个标签可以理解为是name属性的依赖，当我们去修改name时，我们要通知这个依赖重新渲染。</p><p>在收集依赖的过程，要触发get方法，所以我们可以知道，在Watcher里，要有一个key属性，去主动触发get收集。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Watcher</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(vm, key, cb) &#123;</span><br><span class="line">    <span class="keyword">this</span>.vm = vm</span><br><span class="line">    <span class="keyword">this</span>.key = key</span><br><span class="line">    <span class="keyword">this</span>.cb = cb</span><br><span class="line"></span><br><span class="line">    Dep.target = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 添加watcher到dep</span></span><br><span class="line">    <span class="keyword">this</span>.vm[<span class="keyword">this</span>.key]</span><br><span class="line">    Dep.target = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="comment">// 触发更新，重新渲染</span></span><br><span class="line">    <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, <span class="keyword">this</span>.vm[<span class="keyword">this</span>.key])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是Watcher函数的实现，现在再捋一遍代码。首先触发依赖收集是在编译里，编译的过程中，匹配到含有<strong>双括号、my-text</strong>、的这些标签，会分配给它们一个Watcher，这时就会触发Watcher的constructor方法，会先执行Dep.target = this把当前的Watcher赋值给Dep.target，再执行this.vm[this.key]主动触发key的get属性，收集依赖，最后再把Dep.target置为空，这样就把依赖收集了。由于js是单线程的，同一时间只有一个依赖会被收集，所以采用全局的Dep.target方法去实现是没有问题的。</p><h2 id="实现Compile"><a href="#实现Compile" class="headerlink" title="实现Compile"></a>实现Compile</h2><p>其实Compile才是最关键的一步，它的作用就是把模板编译，收集依赖的过程。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compile</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compile</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(el, vm) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$vm = vm</span><br><span class="line">    <span class="keyword">this</span>.$el = <span class="built_in">document</span>.getElementById(el)</span><br><span class="line">    <span class="keyword">this</span>.$fragment = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.$el) &#123;</span><br><span class="line">      <span class="comment">// 提取模板内容到Fragment标签，离线操作dom</span></span><br><span class="line">      <span class="keyword">this</span>.$fragment = node2Fragment(<span class="keyword">this</span>.$el)</span><br><span class="line">      <span class="comment">// 编译模板内容，依赖收集</span></span><br><span class="line">      <span class="keyword">this</span>.compile(<span class="keyword">this</span>.$fragment)</span><br><span class="line">      <span class="comment">// 编译完成最后挂在即可</span></span><br><span class="line">      <span class="keyword">this</span>.$el.appendChild(<span class="keyword">this</span>.$fragment)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 编译</span></span><br><span class="line">  compile(el) &#123;</span><br><span class="line">    <span class="keyword">const</span> childNodes = el.childNodes;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Array</span>.from(childNodes).forEach(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 判断节点类型</span></span><br><span class="line">      <span class="keyword">if</span> (node.nodeType === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 编译元素节点</span></span><br><span class="line">        <span class="keyword">this</span>.compileElement(node)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.isInterpolation(node)) &#123; <span class="comment">// 是插值表达式才进入</span></span><br><span class="line">        <span class="comment">// 编译插值表达式才进入</span></span><br><span class="line">        <span class="keyword">this</span>.compileText(node);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 递归子节点</span></span><br><span class="line">      <span class="keyword">if</span> (node.childNodes &amp;&amp; node.childNodes.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.compile(node);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 编译元素节点</span></span><br><span class="line">  compileElement(node) &#123;</span><br><span class="line">    <span class="comment">// &lt;div my-text="text" @click="onClick"&gt;</span></span><br><span class="line">    <span class="keyword">let</span> nodeAttrs = node.attributes</span><br><span class="line">    <span class="built_in">Array</span>.from(nodeAttrs).forEach(<span class="function"><span class="params">attr</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> attrName = attr.name</span><br><span class="line">      <span class="comment">// 这个exp就是绑定的值</span></span><br><span class="line">      <span class="keyword">const</span> exp = attr.value</span><br><span class="line">      <span class="keyword">if</span> (isDirective(attrName)) &#123; <span class="comment">// 是指令my-开头</span></span><br><span class="line">        <span class="comment">// dir是指令的名称，比如 text html</span></span><br><span class="line">        <span class="keyword">const</span> dir = attrName.substring(<span class="number">3</span>)</span><br><span class="line">        <span class="comment">// 调用this.text或者this.html等方法</span></span><br><span class="line">        <span class="keyword">this</span>[dir] &amp;&amp; <span class="keyword">this</span>[dir](node, <span class="keyword">this</span>.$vm, exp)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isEvent(attrName)) &#123; <span class="comment">// 是事件@开头</span></span><br><span class="line">        <span class="comment">// dir是事件的名称，比如click</span></span><br><span class="line">        <span class="keyword">const</span> dir = attrName.substring(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">this</span>.eventHandler(node, <span class="keyword">this</span>.$vm, exp, dir)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isDirective</span>(<span class="params">attr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> attr.indexOf(<span class="string">"my-"</span>) === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isEvent</span>(<span class="params">attr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> attr.indexOf(<span class="string">"@"</span>) === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 编译文本节点</span></span><br><span class="line">  compileText(node) &#123;</span><br><span class="line">    <span class="comment">// 添加Watcher，收集依赖，触发更新</span></span><br><span class="line">    <span class="keyword">this</span>.update(node, <span class="keyword">this</span>.$vm, <span class="built_in">RegExp</span>.$<span class="number">1</span>, <span class="string">'text'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 渲染text</span></span><br><span class="line">  text(node, vm, exp) &#123;</span><br><span class="line">    <span class="keyword">this</span>.update(node, vm, exp, <span class="string">'text'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 渲染html</span></span><br><span class="line">  html(node, vm, exp) &#123;</span><br><span class="line">    <span class="keyword">this</span>.update(node, vm, exp, <span class="string">'html'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加事件</span></span><br><span class="line">  eventHandler(node, vm, exp, dir) &#123;</span><br><span class="line">    <span class="keyword">const</span> fn = vm.$options.methods &amp;&amp; vm.$options.methods[exp];</span><br><span class="line">    <span class="keyword">if</span> (dir &amp;&amp; fn) &#123;</span><br><span class="line">      node.addEventListener(dir, fn.bind(vm));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  update(node, vm, exp, dir) &#123;</span><br><span class="line">    <span class="keyword">let</span> fun = &#123;</span><br><span class="line">      textUpdater,</span><br><span class="line">      htmlUpdater</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> updatrFn = dir + <span class="string">'Updater'</span> </span><br><span class="line">    updatrFn &amp;&amp; fun[updatrFn](node, vm[exp])</span><br><span class="line">    <span class="comment">// 依赖收集</span></span><br><span class="line">    <span class="keyword">new</span> Watcher(vm, exp, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">      updatrFn &amp;&amp; fun[updatrFn](node, value)</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新方法</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">textUpdater</span>(<span class="params">node, value</span>) </span>&#123;</span><br><span class="line">      node.textContent = value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">htmlUpdater</span>(<span class="params">node, value</span>) </span>&#123;</span><br><span class="line">      node.innerHTML = value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;*el&#125; dom </span></span><br><span class="line"><span class="comment"> * @returns &#123;*dom&#125; fragment</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">node2Fragment</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> fragment = <span class="built_in">document</span>.createDocumentFragment()</span><br><span class="line">  <span class="keyword">let</span> child</span><br><span class="line">  <span class="keyword">while</span> ((child = el.firstChild)) &#123;</span><br><span class="line">    <span class="comment">// appendChild 方法具有可移动性</span></span><br><span class="line"><span class="comment">// 将el中的节点移动到了fragment当中</span></span><br><span class="line">    fragment.appendChild(child)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fragment</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;*node&#125; dom </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isInterpolation</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 是文本且符合&#123;&#123;&#125;&#125;这种形式</span></span><br><span class="line">  <span class="keyword">return</span> node.nodeType === <span class="number">3</span> &amp;&amp; <span class="regexp">/\&#123;\&#123;(.*)\&#125;\&#125;/</span>.test(node.textContent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是Compile的实现，其实大部分都是辅助函数，核心逻辑就是递归循环el的所有子节点，判断对应的插值表达式，执行对应的方法即可。update方法主要是更新dom，以及收集依赖。</p><p>最后，我们只要在new MyVue时候初始化<strong>Compile</strong>函数即可。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">my-text</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"changeName"</span>&gt;</span>点我我就变给你看<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">my-html</span>=<span class="string">"html"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./compile.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./myVue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> myVue = <span class="keyword">new</span> MyVue(&#123;</span></span><br><span class="line"><span class="javascript">      el: <span class="string">'app'</span>,</span></span><br><span class="line">      data: &#123;</span><br><span class="line"><span class="javascript">        name: <span class="string">"我是一个mini的vue"</span>,</span></span><br><span class="line"><span class="xml">        html: '<span class="tag">&lt;<span class="name">h2</span>&gt;</span>这是一个加粗的h2标签<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        changeName() &#123;</span><br><span class="line"><span class="javascript">          <span class="keyword">this</span>.name = <span class="string">'你看我变了吧'</span></span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Myvue.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyVue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$options = options</span><br><span class="line">    <span class="keyword">this</span>.$data = options.data</span><br><span class="line">    <span class="comment">// 响应化处理</span></span><br><span class="line">    <span class="keyword">this</span>.observe(<span class="keyword">this</span>.$data)</span><br><span class="line">    <span class="comment">// 编译模板</span></span><br><span class="line">    <span class="keyword">new</span> Compile(options.el, <span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  observe(value) &#123;</span><br><span class="line">    <span class="comment">// 因为要递归调用，如果不是对象会返回</span></span><br><span class="line">    <span class="keyword">if</span> (!value || <span class="keyword">typeof</span> value !== <span class="string">'object'</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(value).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.defineReactive(value, key, value[key])</span><br><span class="line">      <span class="comment">// 把this.xx代理到this.data.xx</span></span><br><span class="line">      <span class="keyword">this</span>.proxyData(key)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 劫持对象</span></span><br><span class="line">  defineReactive(obj, key, val) &#123;</span><br><span class="line">    <span class="comment">// 每一个属性都有一个dep，用作管理依赖</span></span><br><span class="line">    <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">      <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="comment">// 收集依赖</span></span><br><span class="line">        Dep.target &amp;&amp; dep.addDep(Dep.target)</span><br><span class="line">        <span class="keyword">return</span> val</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span>(newVal) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newVal !== val) &#123;</span><br><span class="line">          val = newVal</span><br><span class="line">          dep.notify()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 递归收集依赖</span></span><br><span class="line">    <span class="keyword">this</span>.observe(val)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 数据代理</span></span><br><span class="line">  proxyData(key) &#123;</span><br><span class="line">    <span class="comment">// 当获取this.xx，则返回this.$data.xx</span></span><br><span class="line">    <span class="comment">// 当修改this.xx，则修改this.$data.xx</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, key, &#123;</span><br><span class="line">      <span class="keyword">get</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$data[key]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span>(newVal)&#123;</span><br><span class="line">        <span class="keyword">this</span>.$data[key] = newVal</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dep</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="comment">// 一个属性可以有多个依赖</span></span><br><span class="line">    <span class="keyword">this</span>.deps = []</span><br><span class="line">  &#125;</span><br><span class="line">  addDep(dep) &#123;</span><br><span class="line">    <span class="keyword">this</span>.deps.push(dep)</span><br><span class="line">  &#125;</span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="keyword">this</span>.deps.forEach(<span class="function"><span class="params">dep</span> =&gt;</span> dep.update())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Dep.target = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Watcher</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(vm, key, cb) &#123;</span><br><span class="line">    <span class="keyword">this</span>.vm = vm</span><br><span class="line">    <span class="keyword">this</span>.key = key</span><br><span class="line">    <span class="keyword">this</span>.cb = cb</span><br><span class="line"></span><br><span class="line">    Dep.target = <span class="keyword">this</span></span><br><span class="line">    <span class="comment">// 添加watcher到dep</span></span><br><span class="line">    <span class="keyword">this</span>.vm[<span class="keyword">this</span>.key]</span><br><span class="line">    Dep.target = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="comment">// 触发更新，重新渲染</span></span><br><span class="line">    <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, <span class="keyword">this</span>.vm[<span class="keyword">this</span>.key])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compile.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compile</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(el, vm) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$vm = vm</span><br><span class="line">    <span class="keyword">this</span>.$el = <span class="built_in">document</span>.getElementById(el)</span><br><span class="line">    <span class="keyword">this</span>.$fragment = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.$el) &#123;</span><br><span class="line">      <span class="comment">// 提取模板内容到Fragment标签，离线操作dom</span></span><br><span class="line">      <span class="keyword">this</span>.$fragment = node2Fragment(<span class="keyword">this</span>.$el)</span><br><span class="line">      <span class="comment">// 编译模板内容，依赖收集</span></span><br><span class="line">      <span class="keyword">this</span>.compile(<span class="keyword">this</span>.$fragment)</span><br><span class="line">      <span class="comment">// 编译完成最后挂在即可</span></span><br><span class="line">      <span class="keyword">this</span>.$el.appendChild(<span class="keyword">this</span>.$fragment)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 编译</span></span><br><span class="line">  compile(el) &#123;</span><br><span class="line">    <span class="keyword">const</span> childNodes = el.childNodes;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Array</span>.from(childNodes).forEach(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 判断节点类型</span></span><br><span class="line">      <span class="keyword">if</span> (node.nodeType === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 编译元素节点</span></span><br><span class="line">        <span class="keyword">this</span>.compileElement(node)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isInterpolation(node)) &#123; <span class="comment">// 是插值表达式才进入</span></span><br><span class="line">        <span class="comment">// 编译插值表达式才进入</span></span><br><span class="line">        <span class="keyword">this</span>.compileText(node);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 递归子节点</span></span><br><span class="line">      <span class="keyword">if</span> (node.childNodes &amp;&amp; node.childNodes.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.compile(node);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 编译元素节点</span></span><br><span class="line">  compileElement(node) &#123;</span><br><span class="line">    <span class="comment">// &lt;div my-text="text" @click="onClick"&gt;</span></span><br><span class="line">    <span class="keyword">let</span> nodeAttrs = node.attributes</span><br><span class="line">    <span class="built_in">Array</span>.from(nodeAttrs).forEach(<span class="function"><span class="params">attr</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> attrName = attr.name</span><br><span class="line">      <span class="comment">// 这个exp就是绑定的值</span></span><br><span class="line">      <span class="keyword">const</span> exp = attr.value</span><br><span class="line">      <span class="keyword">if</span> (isDirective(attrName)) &#123; <span class="comment">// 是指令my-开头</span></span><br><span class="line">        <span class="comment">// dir是指令的名称，比如 text html</span></span><br><span class="line">        <span class="keyword">const</span> dir = attrName.substring(<span class="number">3</span>)</span><br><span class="line">        <span class="comment">// 调用this.text或者this.html等方法</span></span><br><span class="line">        <span class="keyword">this</span>[dir] &amp;&amp; <span class="keyword">this</span>[dir](node, <span class="keyword">this</span>.$vm, exp)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isEvent(attrName)) &#123; <span class="comment">// 是事件@开头</span></span><br><span class="line">        <span class="comment">// dir是事件的名称，比如click</span></span><br><span class="line">        <span class="keyword">const</span> dir = attrName.substring(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">this</span>.eventHandler(node, <span class="keyword">this</span>.$vm, exp, dir)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isDirective</span>(<span class="params">attr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> attr.indexOf(<span class="string">"my-"</span>) === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isEvent</span>(<span class="params">attr</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> attr.indexOf(<span class="string">"@"</span>) === <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 编译文本节点</span></span><br><span class="line">  compileText(node) &#123;</span><br><span class="line">    <span class="comment">// 添加Watcher，收集依赖，触发更新</span></span><br><span class="line">    <span class="keyword">this</span>.update(node, <span class="keyword">this</span>.$vm, <span class="built_in">RegExp</span>.$<span class="number">1</span>, <span class="string">'text'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 渲染text</span></span><br><span class="line">  text(node, vm, exp) &#123;</span><br><span class="line">    <span class="keyword">this</span>.update(node, vm, exp, <span class="string">'text'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 渲染html</span></span><br><span class="line">  html(node, vm, exp) &#123;</span><br><span class="line">    <span class="keyword">this</span>.update(node, vm, exp, <span class="string">'html'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加事件</span></span><br><span class="line">  eventHandler(node, vm, exp, dir) &#123;</span><br><span class="line">    <span class="keyword">const</span> fn = vm.$options.methods &amp;&amp; vm.$options.methods[exp];</span><br><span class="line">    <span class="keyword">if</span> (dir &amp;&amp; fn) &#123;</span><br><span class="line">      node.addEventListener(dir, fn.bind(vm));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  update(node, vm, exp, dir) &#123;</span><br><span class="line">    <span class="keyword">let</span> fun = &#123;</span><br><span class="line">      textUpdater,</span><br><span class="line">      htmlUpdater</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> updatrFn = dir + <span class="string">'Updater'</span> </span><br><span class="line">    updatrFn &amp;&amp; fun[updatrFn](node, vm[exp])</span><br><span class="line">    <span class="comment">// 依赖收集</span></span><br><span class="line">    <span class="keyword">new</span> Watcher(vm, exp, <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">      updatrFn &amp;&amp; fun[updatrFn](node, value)</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新方法</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">textUpdater</span>(<span class="params">node, value</span>) </span>&#123;</span><br><span class="line">      node.textContent = value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">htmlUpdater</span>(<span class="params">node, value</span>) </span>&#123;</span><br><span class="line">      node.innerHTML = value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;*el&#125; dom </span></span><br><span class="line"><span class="comment"> * @returns &#123;*dom&#125; fragment</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">node2Fragment</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> fragment = <span class="built_in">document</span>.createDocumentFragment()</span><br><span class="line">  <span class="keyword">let</span> child</span><br><span class="line">  <span class="keyword">while</span> ((child = el.firstChild)) &#123;</span><br><span class="line">    <span class="comment">// appendChild 方法具有可移动性</span></span><br><span class="line"><span class="comment">// 将el中的节点移动到了fragment当中</span></span><br><span class="line">    fragment.appendChild(child)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fragment</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;*node&#125; dom </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isInterpolation</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 是文本且符合&#123;&#123;&#125;&#125;这种形式</span></span><br><span class="line">  <span class="keyword">return</span> node.nodeType === <span class="number">3</span> &amp;&amp; <span class="regexp">/\&#123;\&#123;(.*)\&#125;\&#125;/</span>.test(node.textContent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在学习vue源码，不断的反复阅读，终于明白vue的核心，是如何收集依赖，触发更新的。下面根据vue的思想，自己实现一个mini版的vue，巩固知识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>前端设计模式</title>
    <link href="http://yoursite.com/2019/12/js-design-pattern/"/>
    <id>http://yoursite.com/2019/12/js-design-pattern/</id>
    <published>2019-12-20T02:16:00.000Z</published>
    <updated>2020-01-15T10:56:37.159Z</updated>
    
    <content type="html"><![CDATA[<p>软件设计模式（Design pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。</p><a id="more"></a><p>其实写代码、写框架、任何事情都有套路，设计模式，就是写代码中的常⻅见套路，有些写法可能我们⽇常都在使⽤，只是我们没有发觉，下面总结一下前端相关的设计模式。</p><h1 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布/订阅模式"></a>发布/订阅模式</h1><blockquote><p>定义：在这种模式中，是一种<strong>一对多</strong>的依赖关系，当一个对象<strong>特定状态</strong>发生改变后，所有依赖它的对象都将会得到通知，这种模式一般以<strong>事件对象的形式传递消息</strong>。</p></blockquote><p><img src="/assets/images/pub-sub.jpg" alt="image"></p><p>订阅者（Subscriber）把自己要订阅的事件注册（Subscribe）到调度中心（Topic），当发布者（Publisher）发布该事件（Publish topic）到调度中心，也就是该事件触发时，再由调度中心通过事件回调通知订阅者。</p><p>ps: js里的dom事件监听，vue中的 on源码都是使用这样的模式；优点：减少代码耦合。</p><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><blockquote><p>定义：保证⼀个类仅有⼀个实例，并提供⼀个访问它的全局访问点。实现的⽅法为先判断实例存在与否，如果存在则直接返回，如果不存在就创建了再返回，这就确保了⼀个类只有 ⼀个实例对象。</p></blockquote><p>element、adtd大部分的弹窗组件，都是使用这种单例模式，保证全局唯一。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Singleton = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.instance = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">Singleton.getInstance = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="keyword">this</span>.instance)&#123;</span><br><span class="line">    <span class="keyword">this</span>.instance = <span class="keyword">new</span> Singleton(name)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.instance</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = Singleton.getInstance(<span class="string">'kim'</span>)</span><br><span class="line"><span class="keyword">var</span> b = Singleton.getInstance(<span class="string">'Queen'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a === b) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><blockquote><p>定义：定义⼀系列的算法，把他们⼀个个封装起来，并且使他们可以相互替换。</p></blockquote><p>比如说，我们有一个需求是根据员绩效来计算获得的股权比例，绩效为B的能拿到的股权为0.04，绩效为A的能拿到0.08。。。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStock</span> (<span class="params">level</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (level = <span class="string">'B'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.04</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (level &gt;= <span class="string">'A'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.08</span></span><br><span class="line">  &#125;...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略模式</span></span><br><span class="line"><span class="keyword">const</span> strategies = &#123;</span><br><span class="line">  <span class="string">"B"</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.04</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"A"</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0.08</span></span><br><span class="line">  &#125;...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStock</span> (<span class="params">level</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> strategies[level]()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法可以让代码更加整洁，如果后期有新增不同的等级，只需加上对应的策略就可以，常见应用：表单验证。</p><p>element-ui里的表单组件示例就是使用这种模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-form :model=&quot;ruleForm&quot; :rules=&quot;rules&quot; ref=&quot;ruleForm&quot; label-width=&quot;100px&quot; class=&quot;demo-ruleForm&quot;&gt;</span><br><span class="line">    &lt;el-form-item label=&quot;活动名称&quot; prop=&quot;name&quot;&gt;</span><br><span class="line">      &lt;el-input v-model=&quot;ruleForm.name&quot;&gt;&lt;/el-input&gt;</span><br><span class="line">    &lt;/el-form-item&gt;</span><br><span class="line">    ...</span><br><span class="line">  &lt;/el-form&gt;</span><br><span class="line">&lt;template/&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        ruleForm: &#123;</span><br><span class="line">          name: &apos;&apos;,</span><br><span class="line">          region: &apos;&apos;,</span><br><span class="line">          date1: &apos;&apos;,</span><br><span class="line">          date2: &apos;&apos;,</span><br><span class="line">          delivery: false,</span><br><span class="line">          type: [],</span><br><span class="line">          resource: &apos;&apos;,</span><br><span class="line">          desc: &apos;&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        rules: &#123;</span><br><span class="line">          name: [</span><br><span class="line">            &#123; required: true, message: &apos;请输入活动名称&apos;, trigger: &apos;blur&apos; &#125;,</span><br><span class="line">            &#123; min: 3, max: 5, message: &apos;长度在 3 到 5 个字符&apos;, trigger: &apos;blur&apos; &#125;</span><br><span class="line">          ],</span><br><span class="line">          region: [</span><br><span class="line">            &#123; required: true, message: &apos;请选择活动区域&apos;, trigger: &apos;change&apos; &#125;</span><br><span class="line">          ],</span><br><span class="line">          date1: [</span><br><span class="line">            &#123; type: &apos;date&apos;, required: true, message: &apos;请选择日期&apos;, trigger: &apos;change&apos; &#125;</span><br><span class="line">          ],</span><br><span class="line">          date2: [</span><br><span class="line">            &#123; type: &apos;date&apos;, required: true, message: &apos;请选择时间&apos;, trigger: &apos;change&apos; &#125;</span><br><span class="line">          ],</span><br><span class="line">          type: [</span><br><span class="line">            &#123; type: &apos;array&apos;, required: true, message: &apos;请至少选择一个活动性质&apos;, trigger: &apos;change&apos; &#125;</span><br><span class="line">          ],</span><br><span class="line">          resource: [</span><br><span class="line">            &#123; required: true, message: &apos;请选择活动资源&apos;, trigger: &apos;change&apos; &#125;</span><br><span class="line">          ],</span><br><span class="line">          desc: [</span><br><span class="line">            &#123; required: true, message: &apos;请填写活动形式&apos;, trigger: &apos;blur&apos; &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      submitForm(formName) &#123;</span><br><span class="line">        this.$refs[formName].validate((valid) =&gt; &#123;</span><br><span class="line">          if (valid) &#123;</span><br><span class="line">            alert(&apos;submit!&apos;);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            console.log(&apos;error submit!!&apos;);</span><br><span class="line">            return false;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line">      resetForm(formName) &#123;</span><br><span class="line">        this.$refs[formName].resetFields();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><blockquote><p>定义：为⼀个对象提供⼀个代⽤品或占位符，以便控制对它的访问。</p></blockquote><p>常见示例：</p><ol><li>图⽚懒加载的⽅式，先通过⼀张loading图占位，然后通过异步的⽅式加载图⽚，等图⽚加载好了再把 完成的图⽚加载到img标签⾥⾯。</li><li>防抖、节流。</li></ol><h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><blockquote><p>定义：通过⼀个中介者对象，其他所有的相关对象都通过该中介者对象来通信，⽽不是相互引⽤，当其中的⼀个对象发⽣改变时，只需要通知中介者对象即可。通过中介者模式可以解除对象与对象之间的紧耦合关系。可以有效的是减少耦合。</p></blockquote><p>常见示例：</p><ol><li>redux，vuex 都属于中介者模式的实际应⽤，我们把共享的数据，抽离成⼀个单独的store， 每个都通过store这个中介来操作对象。</li></ol><h1 id="装饰器模式（高阶函数）"><a href="#装饰器模式（高阶函数）" class="headerlink" title="装饰器模式（高阶函数）"></a>装饰器模式（高阶函数）</h1><blockquote><p>定义：在不改变对象⾃身的基础上，在程序运⾏期间给对象动态地添加⽅法。</p></blockquote><p>常见示例：</p><ol><li>react的⾼阶组件, react-redux中的@connect 、react-router-dom中的withRouter、或者⾃⼰定义⼀些⾼阶组件。</li><li>vue里的指令v-input、v-checkbox等指令。</li><li>antd里的表单组件From。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class CustomizedForm extends React.Component &#123;&#125;</span><br><span class="line"></span><br><span class="line">CustomizedForm = Form.create(&#123;&#125;)(CustomizedForm)</span><br><span class="line"></span><br><span class="line">// 经过 Form.create 包装的组件将会自带 this.props.form 属性，this.props.form 提供的 API 如下：</span><br><span class="line">// getFieldDecorator 用于和表单进行双向绑定</span><br><span class="line">// getFieldError 获取某个输入控件的 Error</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h1><blockquote><p>定义：调用一个方法，实际上多个方法被调用。</p></blockquote><p>常见示例：</p><ol><li>涉及到兼容性，参数⽀持多格式，对外暴露统⼀的api。</li><li>比如vue里的$watch、$on等方法。</li><li>自己封装的组件库等。</li></ol><h1 id="⼯⼚模式"><a href="#⼯⼚模式" class="headerlink" title="⼯⼚模式"></a>⼯⼚模式</h1><blockquote><p>定义：提供创建对象的接⼝，把成员对象的创建⼯作转交给⼀个外部对象，好处在于消除对象之间的耦合。</p></blockquote><p>常见示例：</p><ol><li>弹窗，message，对外提供一个api，然后新建⼀个弹窗或者Message 的实例，就是典型的⼯⼚模式。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createInstance</span> (<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">const</span> instance = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">   instance.name = name;</span><br><span class="line">   instance.age = age;</span><br><span class="line">   <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><blockquote><p>享元(ﬂyweight)模式是⼀种⽤于性能优化的模式，“ﬂy”在这⾥是苍蝇的意思，意为蝇量级。享元模 式的核⼼是运⽤共享技术来有效⽀持⼤量细粒度的对象。 如果系统中因为创建了⼤量类似的对象 ⽽导致内存占⽤过⾼，享元模式就⾮常有⽤了。在 JavaScript 中，浏览器特别是移动端的浏览器 分配的内存并不算多，如何节省内存就成了⼀件⾮常有意义的事情。</p></blockquote><p>常见示例：</p><ol><li>消息组件。（弹窗逻辑⼀样，只是部分属性不同）</li></ol><p>下面用一个图书馆来做示例：每一本书都有唯一的ISBN，Author、Title、checkoutDate、checkoutMember等属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BOOk的构造函数</span></span><br><span class="line"><span class="keyword">var</span> Book = <span class="function"><span class="keyword">function</span>(<span class="params">ISBN, Author, Title, checkoutDate, checkoutMember</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.ISBN = ISBN</span><br><span class="line">  <span class="keyword">this</span>.Author = Author</span><br><span class="line">  <span class="keyword">this</span>.Title = Title</span><br><span class="line">  <span class="keyword">this</span>.checkoutDate = checkoutDate</span><br><span class="line">  <span class="keyword">this</span>.checkoutMember = checkoutMember</span><br><span class="line">&#125;</span><br><span class="line">Book.prototype = &#123;</span><br><span class="line">  getTitle:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.Title</span><br><span class="line">  &#125;,</span><br><span class="line">  getAuthor: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.Author</span><br><span class="line">  &#125;,</span><br><span class="line">  getISBN: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.ISBN</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新借出状态</span></span><br><span class="line">  updateCheckoutStatus: <span class="function"><span class="keyword">function</span> (<span class="params">checkoutDate, checkoutMember</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.checkoutDate = checkoutDate</span><br><span class="line">    <span class="keyword">this</span>.checkoutMember = checkoutMember</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 省略一堆方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序刚开始可能没问题，但是随着时间的增加，图书可能大批量增加，并且每种图书都有不同的版本和数量，你将会发现系统变得越来越慢。几千个book对象在内存里可想而知，我们需要用享元模式来优化。</p><p>优化：我们可以将数据分成内部和外部两种数据，和book对象相关的数据（title, author 等）可以归结为内部属性，而（checkoutDate, checkoutMember等）可以归结为外部属性。这样，同一本书里共享同一个对象了，因为不管谁借的书，只要书是同一本书，基本信息是一样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 享元模式优化代码</span></span><br><span class="line"><span class="keyword">var</span> Book = <span class="function"><span class="keyword">function</span>(<span class="params">ISBN, Author, Title</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.ISBN = ISBN</span><br><span class="line">  <span class="keyword">this</span>.Author = Author</span><br><span class="line">  <span class="keyword">this</span>.Title = Title</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 享元模式一般会结合工厂模式使用，下面定义一个工厂函数</span></span><br><span class="line"><span class="keyword">var</span> BookFactory = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> existingBooks = &#123;&#125; <span class="comment">// 定义存在的书本</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    createBook: <span class="function"><span class="keyword">function</span>(<span class="params">ISBN, Author, Title</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 查找之前是否创建</span></span><br><span class="line">      <span class="keyword">var</span> existingBook = existingBooks[ISBN]</span><br><span class="line">      <span class="keyword">if</span> (existingBook) &#123;</span><br><span class="line">          <span class="keyword">return</span> existingBook</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 如果没有，就创建一个，然后保存</span></span><br><span class="line">          <span class="keyword">const</span> book = <span class="keyword">new</span> Book(ISBN, Author, Title)</span><br><span class="line">          existingBooks[ISBN] = book</span><br><span class="line">          <span class="keyword">return</span> book</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管理外部状态</span></span><br><span class="line"><span class="comment">// 借书管理类</span></span><br><span class="line"><span class="keyword">var</span> BookRecordManager = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> bookRecordDB = &#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 更新借书状态</span></span><br><span class="line">    updateCheckoutStatus: <span class="function"><span class="keyword">function</span> (<span class="params">ISBN, checkoutDate, checkoutMember</span>) </span>&#123;</span><br><span class="line">      bookRecordDB[ISBN].checkoutDate = checkoutDate</span><br><span class="line">      bookRecordDB[ISBN].checkoutMember = checkoutMember</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略一堆方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式，我们做到了将同一种图书的相同信息保存在一个bookmanager对象里，而且只保存一份。</p><p>实现享元模式的关键是把内部状态和外部状态分离开来。有多少种内部状态的组合，系统中便最多存在多少个共享对象，而外部状态储存在共享对象的外部，对于一个程序使用了大量的相似对象有很大的优化。</p><h1 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h1><blockquote><p>职责链模式是个链式结构，请求在链中的节点之间依次传递，直到有一个对象能处理该请求为止。如果没有任何对象处理该请求的话，那么请求就会从链中离开。</p></blockquote><p>假设有一个售卖⼿机的业务，经过分别交纳 500 元定⾦和 200 元定⾦的两轮预定后(订单已 在此时⽣成)，现在已经到了正式购买的阶段。平台会针对⽀付过定⾦的⽤户有⼀定的优惠政策，需求如下</p><ol><li>⽀付过 500 元定⾦的⽤户，会收到 100 元的商城优惠券。</li><li>⽀付过 200 元定⾦的⽤户，会收到 50 元 的商城优惠券。</li><li>没有⽀付定⾦的⽤户只能进⼊普通购买模式，且在库存有限的情况下不⼀定保证能买到。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param orderType 购买模式</span></span><br><span class="line"><span class="comment"> * @param pay 是否已经支付，</span></span><br><span class="line"><span class="comment"> * @param stock 库存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> order = <span class="function"><span class="keyword">function</span> (<span class="params">orderType, pay, stock</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (orderType === <span class="number">1</span>) &#123; <span class="comment">// 500 元定⾦购买模式</span></span><br><span class="line">    <span class="keyword">if</span> (pay === <span class="literal">true</span>) &#123; <span class="comment">// 已⽀付定⾦</span></span><br><span class="line">      <span class="built_in">console</span>.log( <span class="string">'500 元定⾦预购, 得到 100 优惠券'</span> );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 未⽀付定⾦，降级到普通购买模式</span></span><br><span class="line">      <span class="keyword">if</span> (stock &gt; <span class="number">0</span>) &#123; <span class="comment">// ⽤于普通购买的⼿机还有库存</span></span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">'普通购买, ⽆优惠券'</span> );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">'⼿机库存不⾜'</span> );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType === <span class="number">2</span>) &#123; <span class="comment">// 200 元定⾦购买模式</span></span><br><span class="line">    <span class="keyword">if</span> (pay === <span class="literal">true</span>) &#123; <span class="comment">// 已⽀付定⾦</span></span><br><span class="line">      <span class="built_in">console</span>.log( <span class="string">'200 元定⾦预购, 得到 50 优惠券'</span> );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 未⽀付定⾦，降级到普通购买模式</span></span><br><span class="line">      <span class="keyword">if</span> (stock &gt; <span class="number">0</span>) &#123; <span class="comment">// ⽤于普通购买的⼿机还有库存</span></span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">'普通购买, ⽆优惠券'</span> );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">'⼿机库存不⾜'</span> );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (orderType === <span class="number">3</span>) &#123; <span class="comment">// 普通购买模式</span></span><br><span class="line">    <span class="keyword">if</span> (stock &gt; <span class="number">0</span>) &#123; <span class="comment">// ⽤于普通购买的⼿机还有库存</span></span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">'普通购买, ⽆优惠券'</span> );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">'⼿机库存不⾜'</span> );</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">order(<span class="number">1</span>, <span class="literal">true</span>, <span class="number">500</span>) <span class="comment">// 500 元定⾦预购, 得到 100 优惠券</span></span><br></pre></td></tr></table></figure><p>上面代码使用臃肿，下面我们用职责链模式重构这段代码</p><ol><li>先把 500 元订单、200 元订单以及普通购买分成 3 个函数。 </li><li>在把 orderType、pay、stock 这 3 个字段当作参数传递给 500 元订单函数，如果该函数不符合处理条件，则把这个请求传递给后⾯的 200 元订单函数，如果 200 元订单函数依然不能处理该请求，则继续传递请求给普通购买函数。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> order500 = <span class="function"><span class="keyword">function</span>(<span class="params">orderType, pay, stock</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (orderType === <span class="number">1</span> &amp;&amp; pay === <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'500 元定⾦预购，得到 100 优惠券'</span> )</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'nextSuccessor'</span> <span class="comment">// 我不知道下⼀个节点是谁，反正把请求往后⾯传递 &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> order200 = <span class="function"><span class="keyword">function</span>(<span class="params">orderType, pay, stock</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (orderType === <span class="number">2</span> &amp;&amp; pay === <span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'200 元定⾦预购，得到 50 优惠券'</span> )</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'nextSuccessor'</span> <span class="comment">// 我不知道下⼀个节点是谁，反正把请求往后⾯传递 &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> orderNormal = <span class="function"><span class="keyword">function</span>(<span class="params">orderType, pay, stock</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (stock &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'普通购买，⽆优惠券'</span> )</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'⼿机库存不⾜'</span> )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Chain.prototype.setNextSuccessor 指定在链中的下⼀个节点</span></span><br><span class="line"><span class="comment">// Chain.prototype.passRequest 传递请求给某个节点</span></span><br><span class="line"><span class="keyword">var</span> Chain = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.fn = fn</span><br><span class="line"><span class="keyword">this</span>.successor = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line">Chain.prototype.setNextSuccessor = <span class="function"><span class="keyword">function</span> (<span class="params">successor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.successor = successor</span><br><span class="line">&#125;</span><br><span class="line">Chain.prototype.passRequest = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ret = <span class="keyword">this</span>.fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">  <span class="keyword">if</span> (ret === <span class="string">'nextSuccessor'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.successor &amp;&amp; <span class="keyword">this</span>.successor.passRequest.apply( <span class="keyword">this</span>.successor, <span class="built_in">arguments</span> )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> chainOrder500 = <span class="keyword">new</span> Chain(order500)</span><br><span class="line"><span class="keyword">var</span> chainOrder200 = <span class="keyword">new</span> Chain(order200)</span><br><span class="line"><span class="keyword">var</span> chainOrderNormal = <span class="keyword">new</span> Chain(orderNormal)</span><br><span class="line"></span><br><span class="line">chainOrder500.setNextSuccessor(chainOrder200)</span><br><span class="line">chainOrder200.setNextSuccessor(chainOrderNormal)</span><br><span class="line"></span><br><span class="line">chainOrder500.passRequest( <span class="number">1</span>, <span class="literal">true</span>, <span class="number">500</span> ) <span class="comment">// 输出:500 元定⾦预购，得到 100 优惠</span></span><br><span class="line">chainOrder500.passRequest( <span class="number">2</span>, <span class="literal">true</span>, <span class="number">500</span> ) <span class="comment">// 输出:200 元定⾦预购，得到 50 优惠</span></span><br><span class="line">chainOrder500.passRequest( <span class="number">3</span>, <span class="literal">true</span>, <span class="number">500</span> ) <span class="comment">// 输出:普通购买，⽆优惠券</span></span><br><span class="line">chainOrder500.passRequest( <span class="number">1</span>, <span class="literal">false</span>, <span class="number">0</span> )  <span class="comment">// 输出:⼿机库存不⾜</span></span><br></pre></td></tr></table></figure><p>通过改进，我们可以⾃由灵活地增加、移除和修改链中的节点顺序</p><h1 id="适配器-adapter-模式"><a href="#适配器-adapter-模式" class="headerlink" title="适配器(adapter)模式"></a>适配器(adapter)模式</h1><blockquote><p>将一个类（对象）的接口（方法或者属性）<strong>转化</strong>成另外一个接口以满足用户需求，使类（对象）之间接口的不兼容问题通过适配器得以解决。</p></blockquote><p>示例：</p><ol><li>处理兼容性代码。</li><li>传入函数参数统一处理化。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文档说明：</span></span><br><span class="line"><span class="comment"> * 所有的地图都必须实现show接口形式如下</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> googleMap = &#123;</span><br><span class="line">  show () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'开始渲染⾕歌地图'</span> );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> baiduMap = &#123;</span><br><span class="line">  show () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'开始渲染百度地图'</span> );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> mapAdapter = <span class="function"><span class="keyword">function</span> (<span class="params">map</span>) </span>&#123;</span><br><span class="line">  map.show()</span><br><span class="line">&#125;</span><br><span class="line">mapAdapter(googleMap)</span><br><span class="line">mapAdapter(baiduMap)</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.cnblogs.com/TomXu/archive/2012/04/09/2379774.html" target="_blank" rel="noopener"><a href="https://www.cnblogs.com/TomXu/" target="_blank" rel="noopener">汤姆大叔的博客</a></a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;软件设计模式（Design pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>一个中级前端需要掌握的基础函数实现</title>
    <link href="http://yoursite.com/2019/11/write-fun/"/>
    <id>http://yoursite.com/2019/11/write-fun/</id>
    <published>2019-11-09T01:50:00.000Z</published>
    <updated>2020-04-04T05:33:57.174Z</updated>
    
    <content type="html"><![CDATA[<p>用最基础的代码去实现一些函数，从中更加深刻理解方法的使用。</p><a id="more"></a><h1 id="实现call、apply、bind函数"><a href="#实现call、apply、bind函数" class="headerlink" title="实现call、apply、bind函数"></a>实现call、apply、bind函数</h1><h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">content = window, ...rest</span>) </span>&#123;</span><br><span class="line">  content.fn = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> result = content.fn(...rest)</span><br><span class="line">  <span class="keyword">delete</span> content.fn</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现原理：</p><ol><li>在传入的对象里加入一个自定义临时属性<code>fn</code>，值为调用<code>myCall</code>的对象。</li><li>执行<code>content里的fn()</code>方法，此时<code>this</code>指向已发生改变，指向<code>content</code>。</li><li>最终删除临时属性，返回结果即可。</li><li>实际相当于把调用<code>myCall</code>方法里的对象临时存在<code>content.fn</code>里，然后在<code>content</code>里执行调用，改变this执行。</li></ol><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span> (<span class="params">content = window, rest</span>) </span>&#123;</span><br><span class="line">  content.fn = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> result = content.fn(...rest)</span><br><span class="line">  <span class="keyword">delete</span> content.fn</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现原理：同上，只是参数获取的方式不同。</p><h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">content = window, ...rest</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> that = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">const</span> bindFn = <span class="function"><span class="keyword">function</span> (<span class="params">...orderRest</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> that.myCall(content, ...rest, ...orderRest)</span><br><span class="line">  &#125;</span><br><span class="line">  bindFn.prototype = <span class="built_in">Object</span>.create(that.prototype)</span><br><span class="line">  <span class="keyword">return</span> bindFn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bind方法返回的是一个函数，而且这个函数也可以继续接受参数。</p><p>实现原理：</p><ol><li>保存调用对象上下文<code>this</code>为<code>than</code>，定义<code>bindFn</code>函数，返回<code>myCall</code>改变<code>this</code>指向。</li><li>修正<code>bindFn</code>函数原型，返回<code>bindFn</code>。</li></ol><h1 id="节流与去抖"><a href="#节流与去抖" class="headerlink" title="节流与去抖"></a>节流与去抖</h1><h2 id="去抖debounce"><a href="#去抖debounce" class="headerlink" title="去抖debounce"></a>去抖debounce</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span> (<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> content = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">const</span> arg = <span class="built_in">arguments</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">      clearTimeout(timeout)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      fn.apply(content, arg)</span><br><span class="line">    &#125;, wait);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="节流throttle"><a href="#节流throttle" class="headerlink" title="节流throttle"></a>节流throttle</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span> (<span class="params">fn, wait</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> content = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">const</span> arg = <span class="built_in">arguments</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        fn.apply(content, arg)</span><br><span class="line">        timeout = <span class="literal">null</span></span><br><span class="line">      &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该方法没有考虑一些边缘情况，实际上更推荐使用loadash函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">objOrArr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> buf</span><br><span class="line">  <span class="keyword">if</span> (objOrArr <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">    buf = []</span><br><span class="line">    <span class="keyword">const</span> i = objOrArr.length</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      buf[i] = deepClone(objOrArr[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buf;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (objOrArr <span class="keyword">instanceof</span> <span class="built_in">Object</span>) &#123;</span><br><span class="line">    buf = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> k <span class="keyword">in</span> objOrArr) &#123;  <span class="comment">//为这个对象添加新的属性 </span></span><br><span class="line">      buf[k] = deepClone(objOrArr[k]) </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buf</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> objOrArr</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现instanceof功能"><a href="#实现instanceof功能" class="headerlink" title="实现instanceof功能"></a>实现instanceof功能</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原理：能在实例的原型对象链中找到该构造函数的prototype属性所指向的 原型对象，就返回true</span></span><br><span class="line"><span class="comment">// instance.[__proto__...] === instance.constructor.prototype</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span> (<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> proto = left.__proto__</span><br><span class="line">  <span class="keyword">while</span> (proto) &#123;</span><br><span class="line">    <span class="keyword">if</span> (proto === right.prototype) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    proto = proto.__proto__</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="new操作符原理"><a href="#new操作符原理" class="headerlink" title="new操作符原理"></a>new操作符原理</h2><ol><li>创建一个空对象，将它的引用赋给 this，继承函数的原型。</li><li>通过 this 将属性和方法添加至这个对象。</li><li>最后返回 this 指向的新对象（如果没有手动返回其他的对象）。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造器函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span> (<span class="params">Con, ...rest</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个空对象，继承函数的原型</span></span><br><span class="line">  <span class="keyword">let</span> child = <span class="built_in">Object</span>.create(Con.prototype)</span><br><span class="line">  <span class="comment">// 通过 this 将属性和方法添加至这个对象（将this和调用参数传给构造器执行）</span></span><br><span class="line">  <span class="keyword">let</span> result = Con.apply(child, rest)</span><br><span class="line">  <span class="comment">// 最后返回 this 指向的新对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">'object'</span> ? result : child</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于创建一个对象来说，更推荐使用字面量的方式创建对象（无论性能上还是可读性）。因为你使用 <code>new Object()</code> 的方式创建对象需要通过作用域链一层层找到 <code>Object</code>，但是你使用字面量的方式就没这个问题。</p></blockquote><h2 id="组合继承-比较常用的方式"><a href="#组合继承-比较常用的方式" class="headerlink" title="组合继承(比较常用的方式)"></a>组合继承(比较常用的方式)</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'Parent'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">this</span>.type = <span class="string">'Child'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Object.create()生成一个空对象，继承参数。这样就可以隔离开Parent、Child</span></span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype)</span><br><span class="line"><span class="comment">// es6写法</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf( Child.prototype, Parent.prototype )</span><br><span class="line"><span class="comment">// 修正构造函数指向</span></span><br><span class="line">Child.prototype.constructor = Child</span><br><span class="line"><span class="comment">// 最好这么去写</span></span><br><span class="line"><span class="comment">// Object.defineProperty( Child.prototype, "constructor" , &#123;</span></span><br><span class="line"><span class="comment">//  enumerable: false ,</span></span><br><span class="line"><span class="comment">//  writable: true ,</span></span><br><span class="line"><span class="comment">//  configurable: true ,</span></span><br><span class="line"><span class="comment">//  value: Child</span></span><br><span class="line"><span class="comment">//&#125; )</span></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> Child()</span><br></pre></td></tr></table></figure><h2 id="函数科里化"><a href="#函数科里化" class="headerlink" title="函数科里化"></a>函数科里化</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 表示函数形参的个数</span></span><br><span class="line">  <span class="keyword">var</span> length = fn.length</span><br><span class="line">  <span class="keyword">var</span> args = args || []</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    newArgs = args.concat([...arguments])</span><br><span class="line">    <span class="keyword">if</span> (newArgs.length &lt; length) &#123;</span><br><span class="line">      <span class="keyword">return</span> curry.call(<span class="keyword">this</span>, fn, newArgs)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, newArgs)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiFn</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b * c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> multi = curry(multiFn)</span><br><span class="line"></span><br><span class="line">multi(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)</span><br><span class="line">multi(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">multi(<span class="number">2</span>)(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">multi(<span class="number">2</span>,<span class="number">3</span>)(<span class="number">4</span>)</span><br></pre></td></tr></table></figure><h2 id="斐波那契数列及其优化"><a href="#斐波那契数列及其优化" class="headerlink" title="斐波那契数列及其优化"></a>斐波那契数列及其优化</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span> || n === <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化的方法可以利用数组的把值缓存下来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fibonacci = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> temp = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = temp[n]</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> result != <span class="string">'number'</span>) &#123;</span><br><span class="line">      result = fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>)</span><br><span class="line">      temp[n] = result <span class="comment">// 将每次 fibonacci(n) 的值都缓存下来</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;() <span class="comment">// 外层立即执行</span></span><br></pre></td></tr></table></figure><p>另外使用动态规划的空间复杂度更低，也是更推荐的解法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> current = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> next = <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> temp</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    temp = current</span><br><span class="line">    current = next</span><br><span class="line">    next += temp</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> current</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="compose组合函数"><a href="#compose组合函数" class="headerlink" title="compose组合函数"></a>compose组合函数</h2><p>compose的返回值还是一个函数，像’洋葱圈’似的，由内向外，逐步调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compose</span>(<span class="params">...funcs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">arg</span> =&gt;</span> arg</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (funcs.length === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> funcs[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> funcs.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> a(b(...args))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">compose(f,g,h)(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)</span><br></pre></td></tr></table></figure><h2 id="事件中心"><a href="#事件中心" class="headerlink" title="事件中心"></a>事件中心</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">//  事件通道调度中心</span></span><br><span class="line">    <span class="keyword">this</span>._events = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  $on(event, fn) &#123;</span><br><span class="line">    (<span class="keyword">this</span>._events[event] || (<span class="keyword">this</span>._events[event] = [])).push(fn)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">  $once(event, fn) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">on</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.$off(event, on)</span><br><span class="line">      fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 缓存fn，删除时可用到</span></span><br><span class="line">    on.fn = fn</span><br><span class="line">    <span class="keyword">this</span>.$on(event, on)</span><br><span class="line">  &#125;</span><br><span class="line">  $off(event, fn) &#123;</span><br><span class="line">    <span class="keyword">const</span> cbs = <span class="keyword">this</span>._events[event]</span><br><span class="line">    <span class="comment">// 没有传fn，全部回调删除</span></span><br><span class="line">    <span class="keyword">if</span> (!fn) &#123;</span><br><span class="line">      <span class="keyword">this</span>._events[event] = <span class="literal">null</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> cb</span><br><span class="line">    <span class="keyword">let</span> i = cbs.length</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      cb = cbs[i]</span><br><span class="line">      <span class="keyword">if</span> (cb === fn || cb.fn === fn) &#123;</span><br><span class="line">        cbs.splice(i, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  $emit(event) &#123;</span><br><span class="line">    <span class="keyword">let</span> cbs = <span class="keyword">this</span>._events[event]</span><br><span class="line">    <span class="keyword">if</span> (cbs) &#123;</span><br><span class="line">      <span class="keyword">const</span> args = [...arguments]</span><br><span class="line">      cbs.map(<span class="function"><span class="params">item</span> =&gt;</span> item.apply(<span class="keyword">this</span>, args))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现Promise"><a href="#实现Promise" class="headerlink" title="实现Promise"></a>实现Promise</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单版</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span></span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">'resolved'</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> that = <span class="keyword">this</span></span><br><span class="line">  that.state = PENDING</span><br><span class="line">  that.value = <span class="literal">null</span></span><br><span class="line">  that.resolvedCallbacks = []</span><br><span class="line">  that.rejectedCallbacks = []</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (that.state === PENDING) &#123;</span><br><span class="line">      that.state = RESOLVED</span><br><span class="line">      that.value = value</span><br><span class="line">      that.resolvedCallbacks.map(<span class="function"><span class="params">cb</span> =&gt;</span> cb(that.value))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (that.state === PENDING) &#123;</span><br><span class="line">      that.state = REJECTED</span><br><span class="line">      that.value = value</span><br><span class="line">      that.rejectedCallbacks.map(<span class="function"><span class="params">cb</span> =&gt;</span> cb(that.value))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    fn(resolve, reject)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    reject(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> that = <span class="keyword">this</span></span><br><span class="line">  onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="params">v</span> =&gt;</span> v</span><br><span class="line">  onRejected =</span><br><span class="line">    <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span></span><br><span class="line">      ? onRejected</span><br><span class="line">      : <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> r</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="keyword">if</span> (that.state === PENDING) &#123;</span><br><span class="line">    that.resolvedCallbacks.push(onFulfilled)</span><br><span class="line">    that.rejectedCallbacks.push(onRejected)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (that.state === RESOLVED) &#123;</span><br><span class="line">    onFulfilled(that.value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (that.state === REJECTED) &#123;</span><br><span class="line">    onRejected(that.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">1</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="算法及常见问题"><a href="#算法及常见问题" class="headerlink" title="算法及常见问题"></a>算法及常见问题</h1><h2 id="找出字符串中出现次数最多的字符"><a href="#找出字符串中出现次数最多的字符" class="headerlink" title="找出字符串中出现次数最多的字符"></a>找出字符串中出现次数最多的字符</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findMaxRepeatStr</span> (<span class="params">testStr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> testArray = testStr.split(<span class="string">''</span>)</span><br><span class="line">  <span class="keyword">const</span> obj = testArray.reduce(<span class="function">(<span class="params">prev,next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (next <span class="keyword">in</span> prev) &#123;</span><br><span class="line">      prev[next]++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      prev[next] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev</span><br><span class="line">  &#125;,&#123;&#125;)</span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj) <span class="comment">// 获取对象中所有key的值返回数组  [a, b ,c]</span></span><br><span class="line">  <span class="keyword">const</span> values = <span class="built_in">Object</span>.values(obj) <span class="comment">// 获取所有value返回数组  [1, 2, 3]</span></span><br><span class="line">  <span class="keyword">const</span> maxVal = <span class="built_in">Math</span>.max(...values) <span class="comment">// 找出最大的values  3</span></span><br><span class="line">  <span class="keyword">return</span> [keys[values.indexOf(maxVal)] ,maxVal]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(findMaxRepeatStr(<span class="string">'asdasddsfdsfadsfdghdadsdfdgdasd'</span>))</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速排序</span></span><br><span class="line"><span class="comment"> * 是非稳定排序算法 O(nlogn)时间复杂度</span></span><br><span class="line"><span class="comment"> * 原理：1. 从数组中选择一个元素作为基准点</span></span><br><span class="line"><span class="comment"> * 2. 排序数组，所有比基准值小的元素摆放在左边，而大于基准值的摆放在右边。每次分割结束以后基准值会插入到中间去。</span></span><br><span class="line"><span class="comment"> * 3. 后利用递归，将摆放在左边的数组和右边的数组再进行一次上述的1和2操作。</span></span><br><span class="line"><span class="comment"> * 下面这种方法简单，但是内存占用较多。</span></span><br><span class="line"><span class="comment"> * 使用原地排序效果更好更快</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">quickSort</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> pivotIndex = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>) <span class="comment">// 基准位置（理论上可任意选取）</span></span><br><span class="line">  <span class="keyword">const</span> pivot = arr.splice(pivotIndex, <span class="number">1</span>)[<span class="number">0</span>] <span class="comment">// 基准数</span></span><br><span class="line">  <span class="keyword">const</span> left = []</span><br><span class="line">  <span class="keyword">const</span> right = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt; pivot) &#123;</span><br><span class="line">      left.push(arr[i])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 链接左数组、基准数构成的数组、右数组</span></span><br><span class="line">  <span class="keyword">return</span> quickSort(left).concat([pivot], quickSort(right))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> * 无论什么数据进去都是O(n2) 的时间复杂度,数据规模越小越好</span></span><br><span class="line"><span class="comment"> * 通俗来说就是你们中间谁最小谁就出列，站到队列的最后边</span></span><br><span class="line"><span class="comment"> * 然后继续对着剩余的无序数组说你们中间谁最小谁就出列，站到队列的最后边，一直到最后一个，继续站到最后边，这样数组就有了顺序，从小到大。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> length = arr.length</span><br><span class="line">  <span class="keyword">let</span> minIndex, temp</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    minIndex = i</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123; <span class="comment">// 寻找最小的值</span></span><br><span class="line">        minIndex = j <span class="comment">// 将最小数的索引保存</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    temp = arr[i]</span><br><span class="line">    arr[i] = arr[minIndex]</span><br><span class="line">    arr[minIndex] = temp</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> * O(n2) 的时间复杂度,不稳定</span></span><br><span class="line"><span class="comment"> * 原理：比较相邻的两个元素，如果前一个比后一个大，则交换位置</span></span><br><span class="line"><span class="comment"> * 这样一来，第一轮就可以选出一个最大的数放在最后面；那么经过 n-1（数组的 length - 1） 轮，就完成了所有数的排序。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> length = arr.length</span><br><span class="line">  <span class="keyword">let</span> temp</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">      <span class="comment">// 相邻元素两两对比，元素交换，大的元素交换到后面</span></span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        temp = arr[j]</span><br><span class="line">        arr[j] = arr[j + <span class="number">1</span>]</span><br><span class="line">        arr[j + <span class="number">1</span>] = temp</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 希尔排序</span></span><br><span class="line"><span class="comment"> * 是非稳定排序算法 O(nlogn)时间复杂度</span></span><br><span class="line"><span class="comment"> * 原理：希尔排序是按一定的间隔对数列进行分组，</span></span><br><span class="line"><span class="comment"> * 然后在每一个分组中做插入排序；随后逐次缩小间隔，在每一个分组中做插入排序...直到间隔等于1，做一次插入排序后结束。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> length = arr.length</span><br><span class="line">  <span class="keyword">let</span> gag = <span class="number">1</span> <span class="comment">// 初始化间隔为1</span></span><br><span class="line">  <span class="keyword">let</span> temp</span><br><span class="line">  <span class="keyword">while</span> (gag &lt; length / <span class="number">3</span>) &#123; <span class="comment">// 动态定义间隔序列</span></span><br><span class="line">    gag = gag * <span class="number">3</span> + <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (gag; gag &gt; <span class="number">0</span>; gag = <span class="built_in">Math</span>.floor(gag / <span class="number">3</span>)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = gag; i &lt; length; i++) &#123;</span><br><span class="line">      temp = arr[i]</span><br><span class="line">      <span class="keyword">let</span> j = i - gag</span><br><span class="line">      <span class="keyword">for</span> (j; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gag) &#123;</span><br><span class="line">        arr[j + gag] = arr[j]</span><br><span class="line">      &#125;</span><br><span class="line">      arr[j + gag] = temp</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用最基础的代码去实现一些函数，从中更加深刻理解方法的使用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>在Vue项目中使用vw实现移动端适配</title>
    <link href="http://yoursite.com/2019/09/vue-vw/"/>
    <id>http://yoursite.com/2019/09/vue-vw/</id>
    <published>2019-09-30T00:52:00.000Z</published>
    <updated>2019-10-19T06:14:20.934Z</updated>
    
    <content type="html"><![CDATA[<p>移动端适配是前端要面对的很实在的问题，从rem到vw方案，都还是存在一定的缺陷，其实就是没有哪一个方案是完美的。使用<code>vw</code>来做移动端适配，是目前比较流行的做法。（来自大漠老师的文章）<a href="https://www.w3cplus.com/mobile/vw-layout-in-vue.html" target="_blank" rel="noopener">如何在Vue项目中使用vw实现移动端适配</a></p><a id="more"></a><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p>直入主题，我们先实现效果，再细说具体的内容。</p><h3 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yarn add</span><br><span class="line">postcss-import</span><br><span class="line">postcss-url</span><br><span class="line">postcss-aspect-ratio-mini</span><br><span class="line">postcss-write-svg</span><br><span class="line">postcss-preset-env</span><br><span class="line">postcss-px-to-viewport</span><br><span class="line">cssnano</span><br><span class="line">cssnano-preset-advanced -D</span><br></pre></td></tr></table></figure><h3 id="修改对应的文件"><a href="#修改对应的文件" class="headerlink" title="修改对应的文件"></a>修改对应的文件</h3><p>postcss.config.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: &#123;</span><br><span class="line">    <span class="string">'postcss-import'</span>: &#123;&#125;,</span><br><span class="line">    <span class="string">'postcss-url'</span>: &#123;&#125;,</span><br><span class="line">    <span class="string">'postcss-aspect-ratio-mini'</span>: &#123;&#125;,</span><br><span class="line">    <span class="string">'postcss-write-svg'</span>: &#123; <span class="string">'utf8'</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">    <span class="comment">// 'postcss-cssnext': &#123;&#125;, // 已被弃用</span></span><br><span class="line">    <span class="string">'postcss-preset-env'</span>: &#123;&#125;,</span><br><span class="line">    <span class="string">'postcss-px-to-viewport'</span>: &#123;</span><br><span class="line">      <span class="string">'viewportWidth'</span>: <span class="number">750</span>, <span class="comment">// 视窗的宽度，对应的是我们设计稿的宽度，一般是750</span></span><br><span class="line">      <span class="string">'viewportHeight'</span>: <span class="number">1334</span>, <span class="comment">// 视窗的高度，根据750设备的宽度来指定，一般指定1334，也可以不配置</span></span><br><span class="line">      <span class="string">'unitPrecision'</span>: <span class="number">3</span>, <span class="comment">// 指定`px`转换为视窗单位值的小数位数（很多时候无法整除）</span></span><br><span class="line">      <span class="string">'viewportUnit'</span>: <span class="string">'vw'</span>, <span class="comment">// 指定需要转换成的视窗单位</span></span><br><span class="line">      <span class="string">'selectorBlackList'</span>: [<span class="regexp">/^.van/</span>, <span class="string">'.ignone'</span>], <span class="comment">// 指定不转换为视窗单位的类（第三方UI、自定义）</span></span><br><span class="line">      <span class="string">'minPixelValue'</span>: <span class="number">1</span>, <span class="comment">// 小于或等于"1px"不转换为视窗单位，你也可以设置为你想要的值</span></span><br><span class="line">      <span class="string">'mediaQuery'</span>: <span class="literal">false</span>, <span class="comment">// 是否允许在媒体查询中转换`px`</span></span><br><span class="line">      <span class="string">'cssnano'</span>: &#123; <span class="string">'preset'</span>: <span class="string">'advanced'</span>, <span class="string">'autoprefixer'</span>: <span class="literal">false</span>, <span class="string">'postcss-zindex'</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">  <span class="attr">name</span>=<span class="string">"viewport"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=0"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>在实际撸码过程，不需要进行任何的计算，直接在代码中根据UI稿写px, 如</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.test</span> &#123;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译出来的CSS：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.test</span> &#123;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">5.333vw</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在js和template中编写样式-我们可以定义一个转换数字为vw的工具类"><a href="#在js和template中编写样式-我们可以定义一个转换数字为vw的工具类" class="headerlink" title="在js和template中编写样式, 我们可以定义一个转换数字为vw的工具类"></a>在js和template中编写样式, 我们可以定义一个转换数字为vw的工具类</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utils.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> toVw = <span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ((<span class="built_in">window</span>.Number(num).toFixed(<span class="number">5</span>) / <span class="number">375</span>) * <span class="number">100</span>).toFixed(<span class="number">5</span>) + <span class="string">'vw'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插件作用"><a href="#插件作用" class="headerlink" title="插件作用"></a>插件作用</h2><h3 id="postcss-import"><a href="#postcss-import" class="headerlink" title="postcss-import"></a>postcss-import</h3><p>解决<code>@import</code>引入路径问题, 配合<code>postcss-url</code>让你引入文件变得更轻松</p><h3 id="postcss-url"><a href="#postcss-url" class="headerlink" title="postcss-url"></a>postcss-url</h3><p>处理文件，比如图片文件、字体文件等引用路径</p><h3 id="autoprefixer"><a href="#autoprefixer" class="headerlink" title="autoprefixer"></a>autoprefixer</h3><p>让你在编码时不再需要考虑任何浏览器前缀的问题，可以专心撸码</p><h3 id="cssnano"><a href="#cssnano" class="headerlink" title="cssnano"></a>cssnano</h3><p>压缩和清理CSS代码。在webpack中，cssnano和css-loader捆绑在一起，所以不需要自己加载它. 要将postcss-zindex设置为false, 否则z-index的值就会重置为1</p><h3 id="postcss-px-to-viewport"><a href="#postcss-px-to-viewport" class="headerlink" title="postcss-px-to-viewport"></a>postcss-px-to-viewport</h3><p>插件主要用来把px单位转换为vw、vh、vmin或者vmax这样的视窗单位，也是vw适配方案的核心插件之一。</p><p>在配置中需要配置相关的几个关键参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"postcss-px-to-viewport"</span>: &#123;</span><br><span class="line">  viewportWidth: <span class="number">750</span>, <span class="comment">// 视窗的宽度，对应的是我们设计稿的宽度，一般是750</span></span><br><span class="line">  viewportHeight: <span class="number">1334</span>, <span class="comment">// 视窗的高度，根据750设备的宽度来指定，一般指定1334，也可以不配置</span></span><br><span class="line">  unitPrecision: <span class="number">3</span>, <span class="comment">// 指定`px`转换为视窗单位值的小数位数（很多时候无法整除）</span></span><br><span class="line">  viewportUnit: <span class="string">'vw'</span>, <span class="comment">// 指定需要转换成的视窗单位，建议使用vw</span></span><br><span class="line">  selectorBlackList: [<span class="string">'.ignore'</span>, <span class="string">'.hairlines'</span>], <span class="comment">// 指定不转换为视窗单位的类，可以自定义，可以无限添加</span></span><br><span class="line">  minPixelValue: <span class="number">1</span>, <span class="comment">// 小于或等于`1px`不转换为视窗单位，你也可以设置为你想要的值</span></span><br><span class="line">  mediaQuery: <span class="literal">false</span> <span class="comment">// 允许在媒体查询中转换`px` &#125;</span></span><br></pre></td></tr></table></figure><h3 id="postcss-aspect-ratio-mini"><a href="#postcss-aspect-ratio-mini" class="headerlink" title="postcss-aspect-ratio-mini"></a>postcss-aspect-ratio-mini</h3><p>处理元素容器宽高比</p><h3 id="postcss-write-svg"><a href="#postcss-write-svg" class="headerlink" title="postcss-write-svg"></a>postcss-write-svg</h3><p>处理移动端1px的解决方案,该插件主要使用的是border-image和background来做1px的相关处理</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.w3cplus.com/mobile/vw-layout-in-vue.html" target="_blank" rel="noopener">如何在Vue项目中使用vw实现移动端适配</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;移动端适配是前端要面对的很实在的问题，从rem到vw方案，都还是存在一定的缺陷，其实就是没有哪一个方案是完美的。使用&lt;code&gt;vw&lt;/code&gt;来做移动端适配，是目前比较流行的做法。（来自大漠老师的文章）&lt;a href=&quot;https://www.w3cplus.com/mobile/vw-layout-in-vue.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;如何在Vue项目中使用vw实现移动端适配&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
      <category term="vw" scheme="http://yoursite.com/tags/vw/"/>
    
  </entry>
  
  <entry>
    <title>Vue 项目性能优化</title>
    <link href="http://yoursite.com/2019/08/vue-performance/"/>
    <id>http://yoursite.com/2019/08/vue-performance/</id>
    <published>2019-08-20T10:22:00.000Z</published>
    <updated>2019-08-21T01:52:09.430Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以下内容转自：<a href="https://juejin.im/post/5d548b83f265da03ab42471d?utm_source=gold_browser_extension" target="_blank" rel="noopener">Vue 项目性能优化 — 实践指南（网上最全 / 详细）</a>（部分转载，省略掉部分内容。）</p></blockquote><p>Vue 框架通过数据双向绑定和虚拟 DOM 技术，帮我们处理了前端开发中最脏最累的 DOM 操作部分， 我们不再需要去考虑如何操作 DOM 以及如何最高效地操作 DOM；但 Vue 项目中仍然存在项目首屏优化、Webpack 编译配置优化等问题，所以我们仍然需要去关注 Vue 项目性能方面的优化，使项目具有更高效的性能、更好的用户体验。</p><a id="more"></a><p>本文内容分为以下部分组成：</p><ul><li>Vue 代码层面的优化；</li><li>webpack 配置层面的优化；</li></ul><h1 id="一、代码层面的优化"><a href="#一、代码层面的优化" class="headerlink" title="一、代码层面的优化"></a>一、代码层面的优化</h1><h2 id="1-1、v-if-和-v-show-区分使用场景"><a href="#1-1、v-if-和-v-show-区分使用场景" class="headerlink" title="1.1、v-if 和 v-show 区分使用场景"></a>1.1、v-if 和 v-show 区分使用场景</h2><p>v-if是<strong>真正</strong>的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是<strong>惰性</strong>的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p><p>v-show就简单得多，不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 display 属性进行切换。</p><p>所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</p><h2 id="1-2、computed-和-watch-区分使用场景"><a href="#1-2、computed-和-watch-区分使用场景" class="headerlink" title="1.2、computed 和 watch 区分使用场景"></a>1.2、computed 和 watch 区分使用场景</h2><p><strong>computed</strong>：是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed  的值；<br><strong>watch</strong>：更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p><p><strong>运用场景：</strong></p><ul><li>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</li><li>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li></ul><h2 id="1-3、v-for-遍历必须为-item-添加-key，且避免同时使用-v-if"><a href="#1-3、v-for-遍历必须为-item-添加-key，且避免同时使用-v-if" class="headerlink" title="1.3、v-for 遍历必须为 item 添加 key，且避免同时使用 v-if"></a>1.3、v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</h2><p><strong>（1）v-for 遍历必须为 item 添加 key</strong></p><p>在列表数据进行遍历渲染时，需要为每一项 item 设置唯一 key 值，方便 Vue.js 内部机制精准找到该条列表数据。当 state 更新时，新的状态值和旧的状态值对比，较快地定位到 diff 。</p><p><strong>（2）v-for 遍历避免同时使用 v-if</strong></p><p>v-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候，必要情况下应该替换成 computed 属性。</p><p><strong>推荐：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">"user in activeUsers"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:key</span>=<span class="string">"user.id"</span>&gt;</span></span><br><span class="line">    &#123;&#123; user.name &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  activeUsers: function () &#123;</span><br><span class="line">    return this.users.filter(function (user) &#123;</span><br><span class="line"> return user.isActive</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不推荐：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-for</span>=<span class="string">"user in users"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">v-if</span>=<span class="string">"user.isActive"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:key</span>=<span class="string">"user.id"</span>&gt;</span></span><br><span class="line">    &#123;&#123; user.name &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="1-4、长列表性能优化"><a href="#1-4、长列表性能优化" class="headerlink" title="1.4、长列表性能优化"></a>1.4、长列表性能优化</h2><p>Vue 会通过 Object.defineProperty 对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要 Vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间，那如何禁止 Vue 劫持我们的数据呢？可以通过 Object.freeze 方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">    users: &#123;&#125;</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">async</span> created() &#123;</span><br><span class="line">    <span class="keyword">const</span> users = <span class="keyword">await</span> axios.get(<span class="string">"/api/users"</span>);</span><br><span class="line">    <span class="keyword">this</span>.users = <span class="built_in">Object</span>.freeze(users);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1-5、事件的销毁"><a href="#1-5、事件的销毁" class="headerlink" title="1.5、事件的销毁"></a>1.5、事件的销毁</h2><p>Vue 组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。 如果在 js 内使用 addEventListene 等方式是不会自动销毁的，我们需要在组件销毁时手动移除这些事件的监听，以免造成内存泄露，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">created() &#123;</span><br><span class="line">  addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.click, <span class="literal">false</span>)</span><br><span class="line">&#125;,</span><br><span class="line">beforeDestroy() &#123;</span><br><span class="line">  removeEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>.click, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-6、图片资源懒加载"><a href="#1-6、图片资源懒加载" class="headerlink" title="1.6、图片资源懒加载"></a>1.6、图片资源懒加载</h2><p>对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样对于页面加载性能上会有很大的提升，也提高了用户体验。我们在项目中使用 Vue 的 vue-lazyload 插件。</p><h2 id="1-7、路由懒加载"><a href="#1-7、路由懒加载" class="headerlink" title="1.7、路由懒加载"></a>1.7、路由懒加载</h2><p>Vue  是单页面应用，可能会有很多的路由引入 ，这样使用 webpcak 打包后的文件很大，当进入首页时，加载的资源过多，页面会出现白屏的情况，不利于用户体验。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应的组件，这样就更加高效了。这样会大大提高首屏显示的速度，但是可能其他的页面的速度就会降下来。</p><p><strong>路由懒加载：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Answer = <span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">'views/student/Answer'</span>).then(<span class="function">(<span class="params"><span class="built_in">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="built_in">module</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">'/answer'</span>, <span class="attr">component</span>: Answer &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="1-8、第三方插件的按需引入"><a href="#1-8、第三方插件的按需引入" class="headerlink" title="1.8、第三方插件的按需引入"></a>1.8、第三方插件的按需引入</h2><p>我们在项目中经常会需要引入第三方插件（UI组件库），如果我们直接引入整个插件，会导致项目的体积太大，我们可以借助 babel-plugin-component ，然后可以只引入需要的组件，以达到减小项目体积的目的。</p><h2 id="1-9、优化无限列表性能"><a href="#1-9、优化无限列表性能" class="headerlink" title="1.9、优化无限列表性能"></a>1.9、优化无限列表性能</h2><p>如果你的应用存在非常长或者无限滚动的列表，那么需要采用窗口化的技术来优化性能，只需要渲染少部分区域的内容，减少重新渲染组件和创建 dom 节点的时间。 你可以参考以下开源项目 <a href="https://github.com/tangbc/vue-virtual-scroll-list" target="_blank" rel="noopener">vue-virtual-scroll-list</a>和<a href="https://github.com/Akryum/vue-virtual-scroller" target="_blank" rel="noopener">vue-virtual-scroller</a> 来优化这种无限列表的场景的。</p><h2 id="1-10、服务端渲染-SSR-or-预渲染"><a href="#1-10、服务端渲染-SSR-or-预渲染" class="headerlink" title="1.10、服务端渲染 SSR or 预渲染"></a>1.10、服务端渲染 SSR or 预渲染</h2><p>服务端渲染是指 Vue 在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的 html 片段直接返回给客户端这个过程就叫做服务端渲染。</p><p><strong>（1）服务端渲染的优点：</strong></p><ul><li>更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；</li><li>更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；</li></ul><p><strong>（2）服务端渲染的缺点：</strong></p><ul><li>更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；</li><li>更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源，因此如果你预料在高流量环境下使用，请准备相应的服务器负载，并明智地采用缓存策略。</li></ul><p>如果你的项目的 SEO 和 首屏渲染是评价项目的关键指标，那么你的项目就需要服务端渲染来帮助你实现最佳的初始加载性能和 SEO，具体的 Vue SSR 如何实现，可以参考作者的另一篇文章<a href="https://juejin.im/post/5cb6c36e6fb9a068af37aa35" target="_blank" rel="noopener">《Vue SSR 踩坑之旅》</a>。如果你的 Vue 项目只需改善少数营销页面（例如 /， /about，/contact等）的 SEO，那么你可能需要预渲染，在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点，具体你可以使用<a href="https://github.com/chrisvfritz/prerender-spa-plugin" target="_blank" rel="noopener">prerender-spa-plugin</a>就可以轻松地添加预渲染 。</p><h1 id="二、Webpack-层面的优化"><a href="#二、Webpack-层面的优化" class="headerlink" title="二、Webpack 层面的优化"></a>二、Webpack 层面的优化</h1><h2 id="2-1、Webpack-对图片进行压缩"><a href="#2-1、Webpack-对图片进行压缩" class="headerlink" title="2.1、Webpack 对图片进行压缩"></a>2.1、Webpack 对图片进行压缩</h2><p>在 vue 项目中除了可以在<code>webpack.base.conf.js</code>中<code>url-loader</code>中设置 limit 大小来对图片处理，对小于 limit 的图片转化为 base64 格式，其余的不做操作。所以对有些较大的图片资源，在请求资源的时候，加载会很慢，我们可以用<code>image-webpack-loader</code>来压缩图片：</p><p>（1）首先，安装 image-webpack-loader ：</p><p><code>npm install image-webpack-loader --save-dev</code></p><p>（2）然后，在 webpack.base.conf.js 中进行配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,</span><br><span class="line">  use:[</span><br><span class="line">    &#123;</span><br><span class="line">    loader: &apos;url-loader&apos;,</span><br><span class="line">    options: &#123;</span><br><span class="line">      limit: 10000,</span><br><span class="line">      name: utils.assetsPath(&apos;img/[name].[hash:7].[ext]&apos;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      loader: &apos;image-webpack-loader&apos;,</span><br><span class="line">      options: &#123;</span><br><span class="line">        bypassOnDebug: true,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2、提取公共代码"><a href="#2-2、提取公共代码" class="headerlink" title="2.2、提取公共代码"></a>2.2、提取公共代码</h2><p>如果项目中没有去将每个页面的第三方库和公共模块提取出来，则项目会存在以下问题：</p><ul><li>相同的资源被重复加载，浪费用户的流量和服务器的成本。</li><li>每个页面需要加载的资源太大，导致网页首屏加载缓慢，影响用户体验。</li></ul><p>所以我们需要将多个页面的公共代码抽离成单独的文件，来优化以上问题 。Webpack 内置了专门用于提取多个Chunk 中的公共部分的插件 CommonsChunkPlugin，我们在项目中 CommonsChunkPlugin 的配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 所有在 package.json 里面依赖的包，都会被打包进 vendor.js 这个文件中。</span><br><span class="line">new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  name: &apos;vendor&apos;,</span><br><span class="line">  minChunks: function(module, count) &#123;</span><br><span class="line">    return (</span><br><span class="line">      module.resource &amp;&amp;</span><br><span class="line">      /\.js$/.test(module.resource) &amp;&amp;</span><br><span class="line">      module.resource.indexOf(</span><br><span class="line">        path.join(__dirname, &apos;../node_modules&apos;)</span><br><span class="line">      ) === 0</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;),</span><br><span class="line">// 抽取出代码模块的映射关系</span><br><span class="line">new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  name: &apos;manifest&apos;,</span><br><span class="line">  chunks: [&apos;vendor&apos;]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="2-3、模板预编译"><a href="#2-3、模板预编译" class="headerlink" title="2.3、模板预编译"></a>2.3、模板预编译</h2><p>当使用 DOM 内模板或 JavaScript 内的字符串模板时，模板会在运行时被编译为渲染函数。通常情况下这个过程已经足够快了，但对性能敏感的应用还是最好避免这种用法。<br>预编译模板最简单的方式就是使用<a href="https://cn.vuejs.org/v2/guide/single-file-components.html" target="_blank" rel="noopener">单文件组件</a>——相关的构建设置会自动把预编译处理好，所以构建好的代码已经包含了编译出来的渲染函数而不是原始的模板字符串。<br>如果你使用 webpack，并且喜欢分离 JavaScript 和模板文件，你可以使用 <a href="https://github.com/ktsn/vue-template-loader" target="_blank" rel="noopener">vue-template-loader</a>，它也可以在构建过程中把模板文件转换成为 JavaScript 渲染函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;以下内容转自：&lt;a href=&quot;https://juejin.im/post/5d548b83f265da03ab42471d?utm_source=gold_browser_extension&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Vue 项目性能优化 — 实践指南（网上最全 / 详细）
&lt;/a&gt;（部分转载，省略掉部分内容。）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Vue 框架通过数据双向绑定和虚拟 DOM 技术，帮我们处理了前端开发中最脏最累的 DOM 操作部分， 我们不再需要去考虑如何操作 DOM 以及如何最高效地操作 DOM；但 Vue 项目中仍然存在项目首屏优化、Webpack 编译配置优化等问题，所以我们仍然需要去关注 Vue 项目性能方面的优化，使项目具有更高效的性能、更好的用户体验。&lt;/p&gt;
    
    </summary>
    
    
      <category term="转载" scheme="http://yoursite.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>js运行机制和事件循环</title>
    <link href="http://yoursite.com/2019/08/js-runtime-eventLoop/"/>
    <id>http://yoursite.com/2019/08/js-runtime-eventLoop/</id>
    <published>2019-08-19T10:22:00.000Z</published>
    <updated>2019-11-13T01:22:26.894Z</updated>
    
    <content type="html"><![CDATA[<p>js是单线程的脚本语言，在同一时间，只能做同一件事，为了协调事件、用户交互、脚本、UI渲染和网络处理等行为，防止主线程阻塞。运用事件循环机制，js可单线程、异步、非阻塞的去运行代码。</p><a id="more"></a><h1 id="JavaScript执行机制"><a href="#JavaScript执行机制" class="headerlink" title="JavaScript执行机制"></a>JavaScript执行机制</h1><p>我们知道JavaScript语言的执行是单线的。单线程，就是指一次只执行一个任务，如果有多个任务，就必须排队，前面一个任务完成，才能执行后面任务。</p><p>这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等待，会拖延整个程序的执行。</p><p>但是js的特性异步、非阻塞，解决了上述的问题。js将任务的执行模式分成两种：同步(Synchronous)和异步(Asynchronous)。</p><p>JavaScript执行机制:</p><ol><li>主线程运行的时候会生成堆（heap）和栈（stack）。</li><li>js从上到下解析方法，将其中的同步任务按照执行顺序排列到执行栈中。</li><li>当遇到异步任务的时候，会将异步函数交给相应的Webapi，而继续执行后面的任务。</li><li>Webapi会在条件满足的时候，将异步对应的回调加入到“任务队列”中，等待执行。</li><li>执行栈中的所有同步任务执行完毕，系统就会读取”任务队列”，如果有执行任务，则进入执行栈，开始执行。</li><li>完成后出栈，执行栈再次为空。主线程不断重复上面的操作，这就是事件循环（Event Loop）机制。</li></ol><h1 id="JavaScript执行机制中名词理解"><a href="#JavaScript执行机制中名词理解" class="headerlink" title="JavaScript执行机制中名词理解"></a>JavaScript执行机制中名词理解</h1><h2 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h2><p>当我们调用一个方法的时候，js会生成一个与这个方法相对应的执行环境，也叫执行上下文，这个执行环境存在着这个方法的私有作用域、参数、this对象等等。因为js是单线程的，同一时间只能执行一个方法，所以当一系列的方法被依次调用的时候，js会先解析这些方法，把其中的同步任务按照执行顺序排队到一个地方，这个地方叫做执行栈。</p><h2 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h2><p>JavaScript是单线程的，那么这个单线程就成为主线程。而事件循环在主线程执行完执行栈代码后，才执行的。所以主线程代码执行时间过长，会阻塞事件循环的执行。只有当执行栈为空的时候(同步代码执行完毕)，才会执行事件循环来观察有哪些事件回调需要执行，当事件循环检测到任务队列有事件就读取出回调放到执行栈由主线程执行。</p><h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><p>任务队列也有时称叫消息队列、回调队列。</p><p>Js 中，有两类任务队列：宏任务队列（macro tasks）和微任务队列（micro tasks）。宏任务队列可以有多个，微任务队列只有一个。那么什么任务，会分到哪个队列呢？</p><ul><li>宏任务：script（全局任务）, setTimeout, setInterval, setImmediate, I/O, UI rendering。</li><li>微任务：process.nextTick, Promise, Object.observer, MutationObserver。</li></ul><h1 id="浏览器的-Event-Loop"><a href="#浏览器的-Event-Loop" class="headerlink" title="浏览器的 Event Loop"></a>浏览器的 Event Loop</h1><p>浏览器的 Event Loop 遵循的是 HTML5 标准，而 NodeJs 的 Event Loop 遵循的是 libuv。 有所区别。</p><p>Event Loop（事件循环）中，每一次循环称为 tick, 每一次tick的任务如下：</p><ol><li>取一个宏任务来执行。</li><li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中。</li><li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）。</li><li>当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染。</li><li>渲染完毕后，JS引擎线程继续，开始下一个宏任务（从宏任务队列中获取）。</li></ol><p>ps：setTimeout，setInterval，其回调函数会被放到下一个宏任务队列中。</p><h1 id="一个实际例子"><a href="#一个实际例子" class="headerlink" title="一个实际例子"></a>一个实际例子</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'4'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'5'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'6'</span>);</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'7'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'8'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'9'</span>);</span><br></pre></td></tr></table></figure><p>上面代码执行过程：</p><p><strong>第一轮事件循环</strong></p><ul><li>整体script代码(同步代码)作为第一个宏任务进入主线程，遇到console.log，输出1。</li><li>遇到setTimeout,其回调函数被放到宏任务队列中，暂记为setTmineout1。</li><li>遇到console.log，输出5。</li><li>遇到setTimeout,其回调函数被放到宏任务队列中，暂记为setTmineout2。</li><li>遇到console.log，输出9。</li><li>一个宏任务执行结束，去微任务队列查找是否有待执行的任务，没有，结束。</li><li>第一轮循环结束，输出：1 5 9</li></ul><p><strong>第二轮事件循环</strong></p><ul><li>从宏任务队列中取出一个任务，即setTmineout1，开始执行。</li><li>遇到console.log，输出2。</li><li>遇到Promise,创建Promise,输出了3,同时把Promise.then回调函数放到微任务队列。</li><li>一个宏任务执行结束，去微任务队列查找是否有待执行的任务, 发现有微任务，全部取出放到执行栈执行。</li><li>执行微任务，此时就一个微任务，console.log，输出4。</li><li>微任务执行结束。</li><li>第二轮循环结束，输出：2 3 4。</li></ul><p><strong>第三轮事件循环与第二轮一样，输出：6 7 8</strong></p><p><strong>事件循环发现所有任务都已经处理完毕，此时程序执行结束</strong></p><p><strong>全部的输出：1 5 9 2 3 4 6 7 8</strong></p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://blog.csdn.net/dreamingbaobei3/article/details/89520853" target="_blank" rel="noopener">JavaScript运行机制-事件循环与任务队列</a><br><a href="https://juejin.im/post/5be5a0b96fb9a049d518febc" target="_blank" rel="noopener">总结：JavaScript异步、事件循环与消息队列、微任务与宏任务</a><br><a href="https://segmentfault.com/a/1190000011198232?utm_source=tag-newest" target="_blank" rel="noopener">JavaScript 异步、栈、事件循环、任务队列</a><br><a href="https://segmentfault.com/a/1190000017890121" target="_blank" rel="noopener">JavaScript运行机制和事件循环</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;js是单线程的脚本语言，在同一时间，只能做同一件事，为了协调事件、用户交互、脚本、UI渲染和网络处理等行为，防止主线程阻塞。运用事件循环机制，js可单线程、异步、非阻塞的去运行代码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>理解浏览器缓存机制</title>
    <link href="http://yoursite.com/2019/08/browser-cache/"/>
    <id>http://yoursite.com/2019/08/browser-cache/</id>
    <published>2019-08-14T05:32:00.000Z</published>
    <updated>2019-11-13T02:05:18.221Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器的缓存机制也就是我们说的HTTP缓存机制，其机制是根据HTTP报文的缓存标识进行的。简单的理解就是把一个已经请求过的资源拷贝一份存储起来，当下次需要该资源时，浏览器会根据缓存机制决定直接使用缓存资源还是再次向服务器发送请求。</p><a id="more"></a><h2 id="缓存过程分析"><a href="#缓存过程分析" class="headerlink" title="缓存过程分析"></a>缓存过程分析</h2><p>浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中。</p><ul><li>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</li><li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</li></ul><h2 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h2><h3 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h3><p>浏览器缓存位置分为四种，其优先级顺序如下：</p><ol><li>Service Worker</li><li>Memory Cache</li><li>Disk Cache</li><li>Push Cache</li></ol><h3 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h3><p>Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制<strong>缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的</strong>。</p><h3 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h3><p>Memory Cache 即内存中的缓存，其特点是<strong>容量小、读取高效、持续性短，会随着进程的释放而释放</strong>。</p><ul><li><strong>读取高效</strong>：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。</li><li><strong>持续性短</strong>：一旦该进程关闭，则该进程的内存则会清空。</li></ul><h3 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h3><p>Disk Cache 即磁盘中的缓存，其特点是<strong>容量大、读取缓慢、持续性长，任何资源都能存储到磁盘中。</strong></p><p><em>浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？</em></p><blockquote><p>对于大文件来说，大概率是不存储在内存中的，反之优先.<br><br>当前系统内存使用率高的话，文件优先存储进硬盘</p></blockquote><h3 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h3><p>Push Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，<strong>一旦会话结束就被释放，并且缓存时间也很短暂</strong>，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。</p><p>总结特点：</p><ul><li>所有的资源都能被推送，并且能够被缓存,但是 Edge 和 Safari 浏览器支持相对比较差。</li><li>可以推送 no-cache 和 no-store 的资源。</li><li>一旦连接被关闭，Push Cache 就被释放。</li><li>多个页面可以使用同一个HTTP/2的连接，也就可以使用同一个Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的tab标签使用同一个HTTP连接。</li><li>Push Cache 中的缓存只能被使用一次。</li><li>浏览器可以拒绝接受已经存在的资源推送。</li><li>你可以给其他域名推送资源。</li></ul><p>如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。</p><h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><p>浏览器每次在向服务器发起 HTTP 请求获得资源后，可能会根据不同情况（可能是代码控制如 Service Worker、Push Cache，也可能是根据 HTTP Header 的缓存标识字段）将资源缓存起来。<br>浏览器缓存策略分为强制缓存和协商缓存，是通过设置 HTTP Header 来实现的。</p><h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><p>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。强缓存可以通过设置两种 HTTP Header 实现：<strong>Expires 和 Cache-Control</strong>；强制缓存的情况主要有三种</p><ul><li>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求。</li><li>存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存(暂不分析)。</li><li>存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果（请求返回200的状态码）。</li></ul><h5 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h5><p>这是 HTTP 1.0 的字段，表示缓存到期时间，是一个绝对的时间 (当前时间+缓存时间)，如</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Thu, <span class="number">10</span> Nov <span class="number">2017</span> <span class="number">08</span>:<span class="number">45</span>:<span class="number">11</span> GMT</span><br></pre></td></tr></table></figure><p>如果客户端的时间小于Expires的值时，直接使用缓存结果，不需要再次请求。</p><p>缺点：</p><ol><li>受限于本地时间，如果修改了本地时间，可能会造成缓存失效。</li><li>Expires是HTTP/1.0的字段，但是现在浏览器默认使用的是HTTP/1.1。</li></ol><h5 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h5><p>已知Expires的缺点之后，在HTTP/1.1中，增加了一个字段Cache-control，该字段表示资源缓存的最大有效时间（相对值），在该时间内，客户端不需要向服务器发送请求。</p><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td>public</td><td>所有的内容都可以被缓存 (包括客户端和代理服务器， 如 CDN)</td></tr><tr><td>private</td><td>所有的内容只有客户端才可以缓存，代理服务器不能缓存。默认值。</td></tr><tr><td>max-age</td><td>最大有效时间（max-age=30表示缓存30秒后就过期。）</td></tr><tr><td>s-maxage</td><td>覆盖max-age，作用一样，只在代理服务器中生效。</td></tr><tr><td>must-revalidate</td><td>如果超过了 max-age 的时间，浏览器必须向服务器发送请求，验证资源是否还有效。</td></tr><tr><td>no-store</td><td>所有内容都不走缓存，包括强制和协商缓存。</td></tr><tr><td>no-cache</td><td>资源被缓存，但是立即失效，下次会发起请求验证资源是否过期<br>既要求客户端缓存内容的，只是是否使用这个内容由后续的对比来决定。</td></tr><tr><td>max-stale=30</td><td>30秒内，即使缓存过期吗，也使用该缓存。</td></tr><tr><td>min-fresh=30</td><td>希望在30秒内获取最新的响应。</td></tr></tbody></table><p><strong>PS：这些值可以混合使用，例如 <code>Cache-control:public, max-age=2592000</code></strong></p><h5 id="Expires和Cache-Control对比"><a href="#Expires和Cache-Control对比" class="headerlink" title="Expires和Cache-Control对比"></a>Expires和Cache-Control对比</h5><p>Expires 是http1.0的产物，Cache-Control是http1.1的产物，两者同时存在的话，<strong>Cache-Control优先级高于Expires</strong></p><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程；协商缓存的情况主要有二种</p><ul><li>协商缓存生效，返回304和Not Modified。</li><li>协商缓存失效，返回200和请求结果。</li></ul><p>协商缓存可以通过设置两种 HTTP Header 实现：<strong>Last-Modified 和 ETag</strong> 。</p><h5 id="Last-Modified-amp-If-Modified-Since"><a href="#Last-Modified-amp-If-Modified-Since" class="headerlink" title="Last-Modified &amp; If-Modified-Since"></a>Last-Modified &amp; If-Modified-Since</h5><p>过程：</p><p>1.服务器通过 Last-Modified 字段告知客户端，资源最后一次被修改的时间，例如<code>Last-Modified: Mon, 10 Nov 2018 09:10:11 GMT</code><br>2.浏览器将这个值和内容一起记录在缓存数据库中。<br>3.下一次请求相同资源时，会在请求头中将上次的<code>Last-Modified</code>的值写入到请求头的<code>If-Modified-Since</code>字段。<br>4.服务器会将<code>If-Modified-Since</code>的值与<code>Last-Modified</code>字段进行对比。<strong>如果相等，则表示未修改，响应304；反之，则表示修改了，响应 200 状态码，并返回数据。</strong></p><p>缺陷：</p><ul><li>如果资源更新的速度是秒以下单位，那么该缓存是不能被使用的，因为它的时间单位最低是秒。</li><li>如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成的时间，尽管文件可能没有变化，所以起不到缓存的作用。</li><li>如果本地打开缓存文件，即使没有对文件进行修改，但 Last-Modified 却改变了，导致文件没法使用缓存</li></ul><h5 id="Etag-amp-If-None-Match"><a href="#Etag-amp-If-None-Match" class="headerlink" title="Etag &amp; If-None-Match"></a>Etag &amp; If-None-Match</h5><p><strong>Etag是服务器端在响应请求时用来说明资源在服务器端的唯一标识</strong>。与之对应的是 If-None-Match字段，在协商缓存过程中，浏览器发送的 HTTP 请求中 Header 中会带上 If-None-Match 字段，值为该缓存资源 Etag 属性的值。</p><p>当服务器端接收到带有 If-None-Match 的请求时，则会将 If-None-Match 的值与被请求资源的唯一标识做对比。如果相同，说明资源没有新的修改，则响应 HTTP Status Code 304，浏览器会继续使用缓存资源；如果不同，则说明资源被修改过，则响应 HTTP Status Code 200，并返回最新的资源。</p><h4 id="缓存机制总结"><a href="#缓存机制总结" class="headerlink" title="缓存机制总结"></a>缓存机制总结</h4><p>下面用一张流程图来完整说明当浏览器发起 HTTP 请求时缓存机制的过程：</p><p><img src="/assets/images/browser-cache/1.jpeg" alt="image"></p><h2 id="实际场景应用缓存策略"><a href="#实际场景应用缓存策略" class="headerlink" title="实际场景应用缓存策略"></a>实际场景应用缓存策略</h2><h3 id="频繁变动的资源"><a href="#频繁变动的资源" class="headerlink" title="频繁变动的资源"></a>频繁变动的资源</h3><blockquote><p>Cache-Control: no-cache</p></blockquote><p>对于频繁变动的资源，首先需要使用<code>Cache-Control: no-cache</code> 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。</p><h3 id="不常变化的资源"><a href="#不常变化的资源" class="headerlink" title="不常变化的资源"></a>不常变化的资源</h3><blockquote><p>Cache-Control: max-age=31536000</p></blockquote><p>通常在处理这类资源时，给它们的 Cache-Control 配置一个很大的 max-age=31536000 (一年)，这样浏览器之后请求相同的 URL 会命中强制缓存。而为了解决更新的问题，就需要在文件名(或者路径)中添加 hash， 版本号等动态字符，之后更改动态字符，从而达到更改引用 URL 的目的，让之前的强制缓存失效 (其实并未立即失效，只是不再使用了而已)。<br>在线提供的类库 (如 jquery-3.3.1.min.js, lodash.min.js 等) 均采用这个模式。</p><h2 id="用户行为对浏览器缓存的影响"><a href="#用户行为对浏览器缓存的影响" class="headerlink" title="用户行为对浏览器缓存的影响"></a>用户行为对浏览器缓存的影响</h2><p>所谓用户行为对浏览器缓存的影响，指的就是用户在浏览器如何操作时，会触发怎样的缓存策略。主要有 3 种：</p><ul><li>打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。</li><li>普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。</li><li>强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control: no-cache(为了兼容，还带了 Pragma: no-cache),服务器直接返回 200 和最新内容。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.jianshu.com/p/54cc04190252" target="_blank" rel="noopener">深入理解浏览器的缓存机制</a><br><a href="https://mp.weixin.qq.com/s/d2zeGhUptGUGJpB5xHQbOA" target="_blank" rel="noopener">彻底理解浏览器的缓存机制</a><br><a href="https://juejin.im/post/5c749f6851882562934ca96e" target="_blank" rel="noopener">浏览器缓存机制</a><br><a href="https://juejin.im/post/5c22ee806fb9a049fb43b2c5?utm_source=gold_browser_extension" target="_blank" rel="noopener">一文读懂前端缓存</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;浏览器的缓存机制也就是我们说的HTTP缓存机制，其机制是根据HTTP报文的缓存标识进行的。简单的理解就是把一个已经请求过的资源拷贝一份存储起来，当下次需要该资源时，浏览器会根据缓存机制决定直接使用缓存资源还是再次向服务器发送请求。&lt;/p&gt;
    
    </summary>
    
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>前端监控、埋点技术方案</title>
    <link href="http://yoursite.com/2019/07/js-monitoring/"/>
    <id>http://yoursite.com/2019/07/js-monitoring/</id>
    <published>2019-07-13T05:32:00.000Z</published>
    <updated>2020-01-18T02:34:01.936Z</updated>
    
    <content type="html"><![CDATA[<p>前端代码运行在客户端上，为了让前端能够和后端一样，需要将客户端的前端代码监控起来，当客户端出现故障时，能第一时间通知到前端负责人，定位故障，及时止损。Web页面上的埋点主要通过js完成，在js里面有代码埋点、全埋点、可视化埋点三种方案。</p><a id="more"></a><h2 id="前端监控的作用"><a href="#前端监控的作用" class="headerlink" title="前端监控的作用"></a>前端监控的作用</h2><p>在项目里，产品经理需要统计产品用户使用行为，使用习惯，从而去了解用户群体。升级和迭代产品，使其更加贴近用户。前端也需要实现性能监控和异常监控，从而优化代码，处理异常问题等。</p><p><strong>前端监控可以分为三类：数据监控、性能监控和异常监控。</strong></p><h3 id="数据监控"><a href="#数据监控" class="headerlink" title="数据监控"></a>数据监控</h3><p>每一个决策，每一个迭代都需要分析各种数据，数据中往往会有我们需要的答案。数据监控，就是监听用户的行为，常见的监控项有：</p><ul><li>PV/UV</li><li>用户在每一个页面的停留时间</li><li>用户通过什么入口来访问该网页</li><li>用户在相应的页面中触发的行为</li><li>从用户访问页面的顺序挖掘使用习惯（等等）</li></ul><h3 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h3><p>性能监控指的是监听前端的性能，主要包括监听网页或者说产品在用户端的体验。常见的性能监控项包括：</p><ul><li>不同用户，不同机型和不同系统下的首屏加载时间</li><li>白屏时间</li><li>http 等请求的响应时间</li><li>用户可交互时间</li><li>静态资源整体下载时间</li><li>页面渲染时间</li><li>页面交互动画完成时间</li></ul><h3 id="异常监控"><a href="#异常监控" class="headerlink" title="异常监控"></a>异常监控</h3><p>由于产品的前端代码在执行过程中也会发生异常，报错受网络，机型，业务逻辑影响而且大部分错误难以还原现场。及时的上报异常情况，可以避免线上故障的继续发生。</p><ul><li>Javascript 的异常监控</li><li>HTTP请求错误</li><li>样式丢失的异常监控</li><li>…用户：为什么我按钮按不了？？为什么金额不显示？？….</li></ul><p>面对用户的反馈，开发经常感到困惑：到底有多卡，哪个步骤卡？是个别现象还是大面积都受到了影响？白屏时页面请求的返回码是多少？是被运行商劫持还是CDN出了问题？能让用户用Charles配合抓个包么？如何做有针对性的优化？优化的结果怎么去衡量？</p><p>为了解决这些痛点，我们需要对客户端服务进行基于用户行为的监控。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>这里以首屏时间为例，这里有一种可行的测量方案，准确率在99成以上。</p><p>备注：在做时间相关测量时，不能使用setTimeout和setInterval方法，因为在单线程执行引擎中，<strong>异步队列的执行是不能确保执行时间的</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line">      var timerStart = Date.now();</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 加载其他资源，执行代码blabla --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 路由框架挂载节点 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line">      $(document).ready(function() &#123;</span><br><span class="line">        console.log("DOMready 时间 ", Date.now() - timerStart);</span><br><span class="line">      &#125;);</span><br><span class="line">      $(window).load(function() &#123;</span><br><span class="line">        console.log("所有资源加载完成 时间: ", Date.now() - timerStart);</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="常用前端埋点方案总结"><a href="#常用前端埋点方案总结" class="headerlink" title="常用前端埋点方案总结"></a>常用前端埋点方案总结</h2><p>要实现前端监控，前端就需要埋点和上报数据、后端数据处理及分析。</p><p>目前常见的前端埋点方法分为三种：代码埋点、可视化埋点和无埋点（全埋点）。</p><h3 id="手动埋点"><a href="#手动埋点" class="headerlink" title="手动埋点"></a>手动埋点</h3><p>代码埋点，就是以嵌入代码的形式进行埋点，比如需要监控用户的点击事件，会选择在用户点击时，插入一段代码，保存这个监听行为或者直接将监听行为以某一种数据格式直接传递给服务器。</p><p>这种方式容易入侵业务代码。</p><h3 id="可视化埋点"><a href="#可视化埋点" class="headerlink" title="可视化埋点"></a>可视化埋点</h3><p>通过可视化交互的手段，代替上述的代码埋点。将业务代码和埋点代码分离，提供一个可视化交互的页面，输入为业务代码，通过这个可视化系统，可以在业务代码中自定义的增加埋点事件等等，最后输出的代码耦合了业务代码和埋点代码。缺点就是可以埋点的控件有限，不能手动定制。</p><h3 id="无埋点"><a href="#无埋点" class="headerlink" title="无埋点"></a>无埋点</h3><p>埋点并不是说不需要埋点，而是全部埋点，前端的任意一个事件都被绑定一个标识，所有的事件都别记录下来。通过定期上传记录文件，配合文件解析，解析出来我们想要的数据，并生成可视化报告供专业人员分析因此实现“无埋点”统计。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th>埋点方案</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>代码埋点</td><td>可以按照业务上报详细<br>定制化的数据</td><td>需要开发人员参与，更新维护成本高，无法获得历史数据</td><td>对上下文理解要求较高的业务数据</td></tr><tr><td>全埋点</td><td>对发人员依赖低，仅需嵌入一次SDK<br>可以全量上报通用数据，拿到历史数据</td><td>数量量太大，占用更多资源<br>无法收集业务上下文数据<br>给后续数据筛选和分析带来一定的难度</td><td>上下文相对独立的、通用的数据</td></tr><tr><td>可视化埋点</td><td>对开发人员依赖低<br>可以按照业务需求上报数据<br>对上下文数据有一定收集能力</td><td>标记事件有一定的操作难度，事件需要被更新时无法获得历史数据，界面变化时标记的元素可能失效</td><td>业务上下文数据相对简单，操作交互比较固定的界面</td></tr></tbody></table><p>PS：现在一般都使用无埋点。</p><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="pv值"><a href="#pv值" class="headerlink" title="pv值"></a>pv值</h3><p>PV（page view）即页面浏览量或点击量，是衡量一个网站或网页用户访问量。具体的说，PV值就是所有访问者在24小时（0点到24点）内看了某个网站多少个页面或某个网页多少次。PV是指页面刷新的次数，每一次页面刷新，就算做一次PV流量。</p><h3 id="IP即独立IP数"><a href="#IP即独立IP数" class="headerlink" title="IP即独立IP数"></a>IP即独立IP数</h3><p>IP可以理解为独立IP的访问用户，指1天内使用不同IP地址的用户访问网站的数量，同一IP无论访问了几个页面，独立IP数均为1。但是假如说两台机器访问而使用的是同一个IP，那么只能算是一个IP的访问。</p><h3 id="UV（Unique-visitor）"><a href="#UV（Unique-visitor）" class="headerlink" title="UV（Unique visitor）"></a>UV（Unique visitor）</h3><p>是指通过互联网访问、浏览这个网页的自然人。访问您网站的一台电脑客户端为一个访客。00:00-24:00内相同的客户端只被计算一次。一天内同个访客多次访问仅计算一个UV。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="http://unclechen.github.io/2017/12/24/JS%E5%9F%8B%E7%82%B9%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">JS埋点技术分析</a><br><a href="https://juejin.im/post/5b62d68df265da0f9d1a1cd6" target="_blank" rel="noopener">前端监控和前端埋点方案设计</a><br><a href="https://juejin.im/post/5a3e121451882533f01ec66d" target="_blank" rel="noopener">2017前端监控系统探索总结</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前端代码运行在客户端上，为了让前端能够和后端一样，需要将客户端的前端代码监控起来，当客户端出现故障时，能第一时间通知到前端负责人，定位故障，及时止损。Web页面上的埋点主要通过js完成，在js里面有代码埋点、全埋点、可视化埋点三种方案。&lt;/p&gt;
    
    </summary>
    
    
      <category term="监控" scheme="http://yoursite.com/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>window.performance</title>
    <link href="http://yoursite.com/2019/03/performance/"/>
    <id>http://yoursite.com/2019/03/performance/</id>
    <published>2019-03-22T10:22:00.000Z</published>
    <updated>2019-12-20T06:45:12.197Z</updated>
    
    <content type="html"><![CDATA[<p>最近发现之前公司做的产品问题很多，用户反映加载慢，没有响应等问题，从而触发去熟悉performance相关属性的含义，了解浏览器渲染过程，对之后开发前端异常监控系统做好准备。</p><a id="more"></a><h1 id="Performance属性"><a href="#Performance属性" class="headerlink" title="Performance属性"></a>Performance属性</h1><p><code>Performance</code>接口可以获取到当前页面中与性能相关的信息，下面对<code>Performance</code>的属性一一注释</p><p>Performance下有四个属性</p><ul><li>navigation <strong>对象提供了在指定的时间段里发生的操作相关信息，包括页面是加载还是刷新、发生了多少次重定向等等。Not available in workers.</strong></li><li>timing <strong>对象包含延迟相关的性能信息。Not available in workers.</strong></li><li>timeOrigin <strong>返回性能测量开始时的时间的高精度时间戳。</strong></li><li>memory <strong>这个属性提供了一个可以获取到基本内存使用情况的对象。(非标准，chrome支持)</strong></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">Performance.navigation = &#123;</span><br><span class="line">  redirectCount: <span class="number">0</span> <span class="comment">// 如果有重定向的话，页面通过几次重定向跳转而来</span></span><br><span class="line">  type: <span class="number">0</span> <span class="comment">/* 页面来源类型：</span></span><br><span class="line"><span class="comment">            0   即 TYPE_NAVIGATENEXT 正常进入的页面（非刷新、非重定向等）</span></span><br><span class="line"><span class="comment">            1   即 TYPE_RELOAD       通过 window.location.reload() 刷新的页面</span></span><br><span class="line"><span class="comment">            2   即 TYPE_BACK_FORWARD 通过浏览器的前进后退按钮进入的页面（历史记录）</span></span><br><span class="line"><span class="comment">            255 即 TYPE_UNDEFINED    非以上方式进入的页面</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">&#125;</span><br><span class="line">Performance.timing = &#123;</span><br><span class="line">  connectEnd: <span class="number">1494406626724</span> <span class="comment">/* HTTP（TCP）完成建立连接的时间（完成握手）</span></span><br><span class="line"><span class="comment">                              如果是持久连接，则与 fetchStart 值相等</span></span><br><span class="line"><span class="comment">                              如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接完成的时间</span></span><br><span class="line"><span class="comment">                              提醒：这里握手结束，包括安全连接建立完成、SOCKS 授权通过</span></span><br><span class="line"><span class="comment">                            */</span></span><br><span class="line">  connectStart: <span class="number">1494406626724</span> <span class="comment">/* HTTP（TCP）开始建立连接的时间，</span></span><br><span class="line"><span class="comment">                                如果是持久连接，则与 fetchStart 值相等</span></span><br><span class="line"><span class="comment">                                如果在传输层发生了错误且重新建立连接，则这里显示的是新建立的连接开始的时间</span></span><br><span class="line"><span class="comment">                              */</span></span><br><span class="line">  domComplete: <span class="number">1494406628815</span> <span class="comment">/* DOM 树解析完成，且资源也准备就绪的时间</span></span><br><span class="line"><span class="comment">                                Document.readyState 变为 complete，并将抛出 readystatechange 相关事件</span></span><br><span class="line"><span class="comment">                             */</span></span><br><span class="line">  domContentLoadedEventEnd: <span class="number">1494406627789</span>  <span class="comment">// DOM 解析完成后，网页内资源加载完成的时间（如 JS 脚本加载执行完毕）</span></span><br><span class="line">  domContentLoadedEventStart: <span class="number">1494406627789</span> <span class="comment">// DOM 解析完成后，网页内资源加载开始的时间 // 在 DOMContentLoaded 事件抛出前发生</span></span><br><span class="line">  domInteractive: <span class="number">1494406627789</span> <span class="comment">/* 完成解析 DOM 树的时间，Document.readyState 变为 interactive</span></span><br><span class="line"><span class="comment">                                   并将抛出 readystatechange 相关事件</span></span><br><span class="line"><span class="comment">                                   提醒：只是 DOM 树解析完成，这时候并没有开始加载网页内的资源</span></span><br><span class="line"><span class="comment">                                */</span></span><br><span class="line">  domLoading: <span class="number">1494406627313</span> <span class="comment">/* 开始解析渲染 DOM 树的时间，此时 Document.readyState 变为 loading</span></span><br><span class="line"><span class="comment">                               并将抛出 readystatechange 相关事件</span></span><br><span class="line"><span class="comment">                            */</span></span><br><span class="line">  domainLookupEnd: <span class="number">1494406626724</span> <span class="comment">// DNS 域名查询完成的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等</span></span><br><span class="line">  domainLookupStart: <span class="number">1494406626724</span> <span class="comment">// DNS 域名查询开始的时间，如果使用了本地缓存（即无 DNS 查询）或持久连接，则与 fetchStart 值相等</span></span><br><span class="line">  fetchStart: <span class="number">1494406626724</span> <span class="comment">// 浏览器准备好使用 HTTP 请求抓取文档的时间，这发生在检查本地缓存之前</span></span><br><span class="line">  loadEventEnd: <span class="number">1494406628824</span> <span class="comment">// load 事件的回调函数执行完毕的时间</span></span><br><span class="line">  loadEventStart: <span class="number">1494406628816</span> <span class="comment">// load 事件发送给文档，也即 load 回调函数开始执行的时间 // 注意如果没有绑定 load 事件，值为 0</span></span><br><span class="line">  navigationStart: <span class="number">1494406626724</span> <span class="comment">// 在同一个浏览器上下文中，前一个网页（与当前页面不一定同域）unload 的时间戳，如果无前一个网页 unload ，则与 fetchStart 值相等</span></span><br><span class="line">  redirectEnd: <span class="number">0</span> <span class="comment">// 最后一个 HTTP 重定向完成时的时间。有跳转且是同域名内部的重定向才算，否则值为 0</span></span><br><span class="line">  redirectStart: <span class="number">0</span> <span class="comment">// 第一个 HTTP 重定向发生时的时间。有跳转且是同域名内的重定向才算，否则值为 0</span></span><br><span class="line">  requestStart: <span class="number">1494406626757</span> <span class="comment">// HTTP 请求读取真实文档开始的时间（完成建立连接），包括从本地读取缓存，连接错误重连时，这里显示的也是新建立连接的时间</span></span><br><span class="line">  responseEnd: <span class="number">1494406627304</span> <span class="comment">// HTTP 响应全部接收完成的时间（获取到最后一个字节），包括从本地读取缓存</span></span><br><span class="line">  responseStart: <span class="number">1494406627301</span> <span class="comment">// HTTP 开始接收响应的时间（获取到第一个字节），包括从本地读取缓存</span></span><br><span class="line">  secureConnectionStart: <span class="number">0</span> <span class="comment">// HTTPS 连接开始的时间，如果不是安全连接，则值为 0</span></span><br><span class="line">  unloadEventEnd: <span class="number">1494406627304</span> <span class="comment">// 和 unloadEventStart 相对应，返回前一个网页 unload 事件绑定的回调函数执行完毕的时间戳 </span></span><br><span class="line">  unloadEventStart: <span class="number">1494406627304</span> <span class="comment">// 前一个网页（与当前页面同域）unload 的时间戳，如果无前一个网页 unload 或者前一个网页与当前页面不同域，则值为 0</span></span><br><span class="line">&#125;</span><br><span class="line">Performance.timeOrigin = <span class="number">1518354643295.86</span> <span class="comment">// 高精度 timestamp</span></span><br><span class="line">Performance.memory = &#123;</span><br><span class="line">  jsHeapSizeLimit: <span class="number">1136000000</span> <span class="comment">// 内存大小限制</span></span><br><span class="line">  totalJSHeapSize: <span class="number">16100000</span> <span class="comment">// 可使用的内存</span></span><br><span class="line">  usedJSHeapSize: <span class="number">10000000</span> <span class="comment">//JS 对象占用的内存，一定小于 totalJSHeapSize</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="performance方法"><a href="#performance方法" class="headerlink" title="performance方法"></a>performance方法</h1><p><strong>performance.getEntries() 获取静态资源的数组列表</strong></p><p><img src="/assets/images/getEntries.webp" alt="image"></p><p><strong>performance.getEntriesByName(name) 根据资源的name获取相应的数据（如上图中的name）</strong></p><p><strong>performance.getEntriesByType(entryType) 根据资源的name获取相应的数据（如上图中的entryType）</strong></p><h1 id="重要参数指标"><a href="#重要参数指标" class="headerlink" title="重要参数指标"></a>重要参数指标</h1><h2 id="页面性能"><a href="#页面性能" class="headerlink" title="页面性能"></a>页面性能</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> t = performance.timing</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 页面加载完成的时间</span></span><br><span class="line"><span class="comment"> * 这几乎代表了用户等待页面可用的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">loadPage = t.loadEventEnd - t.navigationStart</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析 DOM 树结构的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">domReady = t.domComplete - t.responseEnd</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重定向的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">redirect = t.redirectEnd - t.redirectStart</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DNS 查询时间</span></span><br><span class="line"><span class="comment"> * 可预解析优化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">lookupDomain = t.domainLookupEnd - t.domainLookupStart</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取页面第一个字节的时间</span></span><br><span class="line"><span class="comment"> * 这可以理解为用户拿到你的资源占用的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ttfb = t.responseStart - t.navigationStart</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内容加载完成的时间</span></span><br><span class="line"><span class="comment"> * 启用gzip压缩</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">request = t.responseEnd - t.requestStart</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 执行 onload 回调函数的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">loadEvent = t.loadEventEnd - t.loadEventStart</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DNS 缓存时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">appcache = t.domainLookupStart - t.fetchStart</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 卸载页面的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">unloadEvent = t.unloadEventEnd - t.unloadEventStart</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCP 建立连接完成握手的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">connect = t.connectEnd - t.connectStart</span><br></pre></td></tr></table></figure><h2 id="资源加载监控"><a href="#资源加载监控" class="headerlink" title="资源加载监控"></a>资源加载监控</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> entries = <span class="built_in">window</span>.performance.getEntries() <span class="comment">// 这个函数返回的将是一个数组，包含了页面中所有的 HTTP 请求</span></span><br><span class="line">entries.forEach(<span class="function">(<span class="params">entry</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> times = getEntryTiming(entry)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getEntryTiming</span>(<span class="params">entry</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> t = entry</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    redirect: t.redirectEnd - t.redirectStart, <span class="comment">// 重定向的时间</span></span><br><span class="line">    lookupDomain: t.domainLookupEnd - t.domainLookupStart, <span class="comment">// DNS查询时间</span></span><br><span class="line">    request: t.responseEnd - t.requestStart, <span class="comment">// 内容加载完成的时间</span></span><br><span class="line">    connect: t.connectEnd - t.connectStart, <span class="comment">// TCP建立连接完成握手的时间</span></span><br><span class="line">    name: entry.name,</span><br><span class="line">    entryType: entry.entryType,</span><br><span class="line">    initiatorType: entry.initiatorType,</span><br><span class="line">    duration: entry.duration</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Performance" target="_blank" rel="noopener">Performance</a><br><a href="http://javascript.ruanyifeng.com/bom/performance.html#toc5" target="_blank" rel="noopener">Performance API</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近发现之前公司做的产品问题很多，用户反映加载慢，没有响应等问题，从而触发去熟悉performance相关属性的含义，了解浏览器渲染过程，对之后开发前端异常监控系统做好准备。&lt;/p&gt;
    
    </summary>
    
    
      <category term="性能" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>页面性能优化</title>
    <link href="http://yoursite.com/2018/10/performance-optimize/"/>
    <id>http://yoursite.com/2018/10/performance-optimize/</id>
    <published>2018-10-08T08:11:00.000Z</published>
    <updated>2020-01-13T01:46:16.805Z</updated>
    
    <content type="html"><![CDATA[<p>一个页面的加载速度，与网络、浏览器渲染过程两个方面相关，下面分别从两个方向去讨论如何提升页面加载速度。</p><a id="more"></a><p>在讨论优化页面性能、提高页面加载速度的之前，我们先了解下浏览器渲染页面的原理及过程。</p><h2 id="浏览器如何渲染一个页面"><a href="#浏览器如何渲染一个页面" class="headerlink" title="浏览器如何渲染一个页面"></a>浏览器如何渲染一个页面</h2><p>先看看浏览器工作大流程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">HTML Source           CSS</span><br><span class="line">    |                  |</span><br><span class="line">    |                  |</span><br><span class="line">    |                  |</span><br><span class="line">    |                  |</span><br><span class="line"> Dom Tree          样式结构体（CSSOM）</span><br><span class="line">    \                  /</span><br><span class="line">     \                /</span><br><span class="line">      \              /</span><br><span class="line">       \            /</span><br><span class="line">        \          /</span><br><span class="line">          scripts</span><br><span class="line">             |</span><br><span class="line">             |</span><br><span class="line">         Render Tree（呈现树）</span><br><span class="line">             |</span><br><span class="line">             |</span><br><span class="line">           layout</span><br><span class="line">             |</span><br><span class="line">             |</span><br><span class="line">           paint</span><br></pre></td></tr></table></figure><ol><li>使用HTML代码解析成DOM树。HTML中的每个标签都是DOM树中的一个节点，根节点就是我们常用的document对象。DOM树里包含了所有HTML标签，包括display:none隐藏，还有用JS动态添加的元素等。</li><li>使用 CSS 创建 CSS 对象模型（CSSOM）。</li><li>基于 DOM 和 CSSOM 执行脚本（Scripts）。</li><li>执行完成后，浏览器引擎会通过DOM树和样式结构体来构造<strong>Render Tree</strong>。</li><li>使用渲染树布局（Layout）所有元素。</li><li>渲染（Paint）所有元素。</li></ol><h3 id="渲染步骤一：HTML"><a href="#渲染步骤一：HTML" class="headerlink" title="渲染步骤一：HTML"></a>渲染步骤一：HTML</h3><p>浏览器从上到下读取标签，把他们分解成节点，从而创建 DOM 。</p><h3 id="渲染步骤二：CSS"><a href="#渲染步骤二：CSS" class="headerlink" title="渲染步骤二：CSS"></a>渲染步骤二：CSS</h3><p>当浏览器发现任何与节点相关的样式时，比如：外部，内部，或行内样式，立即停止渲染 DOM ，并利用这些节点创建 CSSOM。这就是 CSS “渲染阻塞“ 的由来。</p><p>CSSOM 的构建会阻塞页面的渲染，因此我们想尽早加载样式。</p><h3 id="渲染步骤三：JavaScript"><a href="#渲染步骤三：JavaScript" class="headerlink" title="渲染步骤三：JavaScript"></a>渲染步骤三：JavaScript</h3><p>浏览器不断构建 DOM / CSSOM 节点，直到发现外部或者行内的脚本。</p><p>由于脚本可能需要访问或操作之前的 HTML 或样式，我们必须等待它们构建完成。</p><p>因此浏览器必须停止解析节点，完成构建 CSSOM，执行脚本，然后再继续。这就是 JavaScript 被称作“解析器阻塞”的原因。脚本只能等到先前的 CSS 节点构建完成。</p><h3 id="渲染步骤四：渲染树（Render-Tree）"><a href="#渲染步骤四：渲染树（Render-Tree）" class="headerlink" title="渲染步骤四：渲染树（Render Tree）"></a>渲染步骤四：渲染树（Render Tree）</h3><p>一旦所有节点已被解析，DOM 和 CSSOM 准备合并，浏览器便会构建渲染树。</p><h3 id="渲染步骤五：布局（Layout）"><a href="#渲染步骤五：布局（Layout）" class="headerlink" title="渲染步骤五：布局（Layout）"></a>渲染步骤五：布局（Layout）</h3><p>布局阶段需要确定页面上所有元素的大小和位置。</p><h3 id="渲染步骤六：渲染（Paint）"><a href="#渲染步骤六：渲染（Paint）" class="headerlink" title="渲染步骤六：渲染（Paint）"></a>渲染步骤六：渲染（Paint）</h3><p>最终的渲染阶段，会真正地光栅化屏幕上的像素，把页面呈现给用户。</p><p><strong>注意：</strong></p><ul><li>DOM树和样式结构体组合后构建<strong>Render Tree</strong>,类似于DOM树，但区别很大。<strong>Render Tree</strong>能识别样式，且每个节点都有自己的style，而且不包含隐藏的节点。（比如display:none的节点，还有head节点），这些节点不会用于呈现，就不会包含到<strong>Render Tree</strong>中。</li><li>CSS匹配HTML元素是一个相当复杂和有性能问题的事情。所以，DOM树要小，CSS尽量用id和class，不要用标签选择器，尽量不要过渡层叠下去。</li></ul><h2 id="回流与重绘"><a href="#回流与重绘" class="headerlink" title="回流与重绘"></a>回流与重绘</h2><h3 id="回流（reflow）"><a href="#回流（reflow）" class="headerlink" title="回流（reflow）"></a>回流（reflow）</h3><p>当<strong>Render Tree</strong>中元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流。每个页面至少需要一次回流，就是在页面第一次加载的时候。回流会从<strong>html</strong>这个<strong>root frame</strong>开始递归往下，依次计算所有的结点几何尺寸和位置。</p><h3 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h3><p>屏幕的一部分要重画，比如某个CSS的背景色变了。但是元素的几何尺寸没有变时，该过程成为重绘。</p><p>回流必将引起重绘，而重绘不一定会引起回流。</p><p>回流发生的情况：</p><ol><li>添加或者删除可见的DOM元素。</li><li>元素位置改变。</li><li>元素尺寸改变：边距、填充、边框、宽度和高度。</li><li>内容改变：比如文本改变或者图片大小改变而引起的计算值宽度和高度改变。</li><li>浏览器窗口尺寸改变：resize事件发生。</li></ol><h3 id="减少回流、重绘"><a href="#减少回流、重绘" class="headerlink" title="减少回流、重绘"></a>减少回流、重绘</h3><p>回流是一个很耗性能的过程。我们要提供渲染性能，就要减少回流和重绘的操作。</p><ol><li>为动画的HTML元素使用fixed或absoult的定位。</li><li>让要操作的元素进行”离线处理”，处理完后一起更新。</li></ol><h2 id="页面性能优化办法（网络、数据方面）"><a href="#页面性能优化办法（网络、数据方面）" class="headerlink" title="页面性能优化办法（网络、数据方面）"></a>页面性能优化办法（网络、数据方面）</h2><h3 id="资源压缩与合并"><a href="#资源压缩与合并" class="headerlink" title="资源压缩与合并"></a>资源压缩与合并</h3><ol><li>html压缩</li><li>css压缩</li><li>js压缩</li><li>文件合并</li></ol><p>要尽可能早的加载样式，尽可能晚的加载脚本。原因是脚本执行之前，需要 HTML 和 CSS 解析完成，因此，样式尽可能的往顶部放，当底部脚本开始执行之前，样式有足够的时间完成计算。</p><h3 id="非核心代码异步加载"><a href="#非核心代码异步加载" class="headerlink" title="非核心代码异步加载"></a>非核心代码异步加载</h3><p>直接使用script，html会按照顺序来加载并执行脚本，在脚本加载执行的过程中，会<strong>阻塞</strong>后续的DOM渲染。所以script提供了async和defer属性来解决上述问题。</p><p>异步加载的方式：defer、async。</p><p><strong>defer</strong></p><ul><li>如果script标签设置了该属性，则浏览器会异步的下载该文件并且不会影响到后续DOM的渲染。</li><li>如果有多个设置了defer的script标签存在，则会<strong>按照顺序执行</strong>所有的script。</li><li>defer脚本会在文档渲染完毕后，DOMContentLoaded事件调用前执行。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"2.js"</span> defer &gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"1.js"</span> defer &gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.js</span></span><br><span class="line"><span class="comment">// 1.js</span></span><br><span class="line"><span class="comment">// DOMContentLoaded</span></span><br></pre></td></tr></table></figure><p>就算1.js加载用时比2.js短，但因为defer的限制，所以1.js只能等前边的脚本执行完毕后才能执行</p><p><strong>async</strong></p><ul><li>async的设置，会使得script脚本异步的加载并在允许的情况下执行。</li><li>async的执行，并不会按着script在页面中的顺序来执行，而是谁先加载完谁执行。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"2.js"</span> <span class="keyword">async</span> &gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"1.js"</span> <span class="keyword">async</span> &gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DOMContentLoaded</span></span><br><span class="line"><span class="comment">// 1.js</span></span><br><span class="line"><span class="comment">// 2.js</span></span><br></pre></td></tr></table></figure><p>注意：<strong>DOMContentLoaded</strong>事件的触发并不受async脚本加载的影响，在脚本加载完之前，就已经触发了<strong>DOMContentLoaded</strong></p><p>async的执行是加载完成就会去执行，而不像defer那样要等待所有的脚本加载完后按照顺序执行。</p><p><strong>普通script</strong><br>文档解析的过程中，如果遇到script脚本，就会停止页面的解析进行下载（但是Chrome会做一个优化，如果遇到script脚本，会快速的查看后边有没有需要下载其他资源的，如果有的话，会先下载那些资源，然后再进行下载script所对应的资源，这样能够节省一部分下载的时间）。<br>资源的下载是在解析过程中进行的，虽然1.js脚本会很快的加载完毕，但是他前边的2.js并没有加载执行，所以他只能处于一个挂起的状态，等待2.js执行完毕后再执行。<br>当这两个脚本都执行完毕后，才会继续解析页面。</p><p><strong>defer</strong></p><p>文档解析时，遇到设置了defer的脚本，就会在后台进行下载，但是并不会阻止文档的渲染，当页面解析&amp;渲染完毕后。<br>会等到所有的defer脚本加载完毕并按照顺序执行，执行完毕后会触发DOMContentLoaded事件。</p><p><strong>async</strong></p><p>async脚本会在加载完毕后执行。<br>async脚本的加载不计入DOMContentLoaded事件统计。</p><h3 id="使用CDN加速"><a href="#使用CDN加速" class="headerlink" title="使用CDN加速"></a>使用CDN加速</h3><p>通过将静态资源(例如javascript，css，图片等等）缓存到离用户很近的相同网络运营商的CDN节点上，不但能提升用户的访问速度，还能节省服务器的带宽消耗，降低负载。</p><h3 id="预解析DNS"><a href="#预解析DNS" class="headerlink" title="预解析DNS"></a>预解析DNS</h3><p>资源预加载是另一个性能优化技术，我们可以使用该技术来预先告知浏览器某些资源可能在将来会被使用到。</p><p>例如，我们将来可从 baidu.com 获取图片或音频资源，那么可以在文档顶部的 标签中加入以下内容。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"x-dns-prefetch-control"</span> <span class="attr">content</span>=<span class="string">"on"</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"//baidu.com"</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="利用浏览器缓存"><a href="#利用浏览器缓存" class="headerlink" title="利用浏览器缓存"></a>利用浏览器缓存</h3><ol><li>强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的network选项中可以看到该请求返回200的状态码，并且size显示from disk cache或from memory cache；</li><li>协商缓存：向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；另外协商缓存需要与cache-control共同使用。</li></ol><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://jinlong.github.io/2017/05/08/optimising-the-front-end-for-the-browser/" target="_blank" rel="noopener">浏览器前端优化</a><br><a href="https://juejin.im/post/5b022bdf518825426d2d69fe" target="_blank" rel="noopener">页面性能优化</a><br><a href="https://coolshell.cn/articles/9666.html" target="_blank" rel="noopener">浏览器的渲染原理简介</a><br><a href="https://www.html.cn/archives/4996" target="_blank" rel="noopener">页面重绘和回流以及优化</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个页面的加载速度，与网络、浏览器渲染过程两个方面相关，下面分别从两个方向去讨论如何提升页面加载速度。&lt;/p&gt;
    
    </summary>
    
    
      <category term="性能" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD/"/>
    
      <category term="HTML" scheme="http://yoursite.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>交互设计原则</title>
    <link href="http://yoursite.com/2018/08/interactive-design/"/>
    <id>http://yoursite.com/2018/08/interactive-design/</id>
    <published>2018-08-11T08:11:00.000Z</published>
    <updated>2019-12-20T01:29:29.762Z</updated>
    
    <content type="html"><![CDATA[<p>好的用户界面-界面设计的一些技巧。</p><blockquote><p>以下内容转自：<a href="https://www.cnblogs.com/Wayou/p/goodui.html" target="_blank" rel="noopener">https://www.cnblogs.com/Wayou/p/goodui.html</a><br><br>英文原文地址：<a href="https://goodui.org/" target="_blank" rel="noopener">https://goodui.org/</a></p></blockquote><a id="more"></a><h2 id="1-尽量使用单列而不是多列布局"><a href="#1-尽量使用单列而不是多列布局" class="headerlink" title="1. 尽量使用单列而不是多列布局"></a>1. 尽量使用单列而不是多列布局</h2><p>单列布局能够让对全局有更好的掌控。同时用户也可以一目了然内容。而多列而已则会有分散用户注意力的风险使你的主旨无法很好表达。最好的做法是用一个有逻辑的叙述来引导用户并且在文末给出你的操作按钮。</p><p><img src="/assets/images/design/1.png" alt="image"></p><h2 id="2-放出礼品往往更具诱惑力"><a href="#2-放出礼品往往更具诱惑力" class="headerlink" title="2. 放出礼品往往更具诱惑力"></a>2. 放出礼品往往更具诱惑力</h2><p>给用户一份精美小礼品这样的友好举动再好不过了。具体来讲，送出礼品也是之有效的获得客户忠诚度的战术，这是建立在人们互惠准则上的。而这样做所带来的好处也是显而易见的，会让你在往后的活动进展（不管是推销，产品更新还是再次搞活动）中更加顺利。</p><p><img src="/assets/images/design/2.png" alt="image"></p><h2 id="3-合并重复的功能而使界面简洁"><a href="#3-合并重复的功能而使界面简洁" class="headerlink" title="3. 合并重复的功能而使界面简洁"></a>3. 合并重复的功能而使界面简洁</h2><p>在整个产品开发期间我们会有意无意地创建很多模块，版面或者元素，而它们的功能可能有些是重叠的。此种情况表明界面已经过度设计了。时刻警惕这些冗余的功能模块，它无用且降低了电脑性能。此外，界面上模块越多，用户的学习成本就越大。所以请考虑重构你的界面使它足够精简。</p><p><img src="/assets/images/design/3.png" alt="image"></p><h2 id="4-客户的评价好过自吹自擂"><a href="#4-客户的评价好过自吹自擂" class="headerlink" title="4. 客户的评价好过自吹自擂"></a>4. 客户的评价好过自吹自擂</h2><p>在获得项目机会或提高项目转化率时客户的好评是一种极为有效的手段。当潜在客户看到其他人对你的服务给予好评时，项目机会会大增。所以试着提供一些含金量高的证据证明这些好评是真实可信的。</p><p><img src="/assets/images/design/4.png" alt="image"></p><h2 id="5-频繁展示你的主旨来加深印象"><a href="#5-频繁展示你的主旨来加深印象" class="headerlink" title="5. 频繁展示你的主旨来加深印象"></a>5. 频繁展示你的主旨来加深印象</h2><p>多次重复主旨口号这种方法适用于界面很长或者分页的情况。首先你肯定不想满屏刷出相同的信息，这样会让人生厌。但当页面足够长的时候这些重复就显示自然多了并且也不显得拥挤。所在在页面顶部放一个按钮然后在页面底部再适当放个突出的按钮的做法没有什么不妥。这样当用户到达页面底部在思考接下来该做什么的时候，你提供的按钮就可以获得一个潜在的合同或者即使用户不需要你的服务这个按钮也可以起到过滤的作用。</p><p><img src="/assets/images/design/5.png" alt="image"></p><h2 id="6-将选项与按钮区分开来"><a href="#6-将选项与按钮区分开来" class="headerlink" title="6. 将选项与按钮区分开来"></a>6. 将选项与按钮区分开来</h2><p>诸如颜色，层次及模块间的对比这些视觉上的设计可以很好地帮助用户使用产品：他时刻知道当前所处的页面以及可以转到哪些页面。要传达这样一个好的界面，你就需要将可点击的元素（比如连接，按钮），可选择的元素（比如单选多选框）以及普通的文字明显区分开来。在下图的例子中，我将点击操作的元素设置为蓝色，选中的当前元素为黑色。这样适当的设计可以让用户很方面地在产品的各模块间切换。但千万不要把这三种元素设计得混乱不堪。</p><p><img src="/assets/images/design/6.png" alt="image"></p><h2 id="7-给出推荐而不是让用户来选择"><a href="#7-给出推荐而不是让用户来选择" class="headerlink" title="7. 给出推荐而不是让用户来选择"></a>7. 给出推荐而不是让用户来选择</h2><p>当展示许多项服务时，给出一个重磅的推荐项是个不错的做法，尽管推荐的设置无法满足所有用户。这么做是有理论依据的，一些研究已经揭示了这么一种现象：当面临的选择越多时，用户就越难做出决定。所以你可以高亮某个选项来帮助用户做出选择。</p><p><img src="/assets/images/design/7.png" alt="image"></p><h2 id="8-给出撤销操作来代替确定操作"><a href="#8-给出撤销操作来代替确定操作" class="headerlink" title="8. 给出撤销操作来代替确定操作"></a>8. 给出撤销操作来代替确定操作</h2><p>假设你刚点击了一个连接或者按钮，撤销操作可以让操作流畅自然，这也符合人类的本能。而每次操作都弹一个确定框则好像是在质问用户你明白不明白这个操作会产生什么后果。我还是更习惯假设用户每次操作都是正确的，其实只有极少数情况下才会发生误操作。所以，为了防止误操作而设计的确认窗口其实是不人性化的，用户每次操作都需要进行毫无意义的确定。所以请考虑在你的产品里实现撤销操作来增加用户的操作友好度吧。</p><p><img src="/assets/images/design/8.png" alt="image"></p><h2 id="9-指出产品适用人群而不是做成全年龄"><a href="#9-指出产品适用人群而不是做成全年龄" class="headerlink" title="9. 指出产品适用人群而不是做成全年龄"></a>9. 指出产品适用人群而不是做成全年龄</h2><p>你是想把产品做成大众化的呢还是有精确的适用人群？在产品定位上你需要更精确些。通过不断了解目标客户的需求及标准，你能把产品做得更好得到更多与客户交流的机会，并且让客户觉得你很专业，在这方面是独家提供的优质服务。把产品定位得精确的风险就是可能缩小了目标潜在客户的范围，也使自身变得不那么全能。但这种做得更专业的精神却反过来会赢得信任，权威。</p><p><img src="/assets/images/design/9.png" alt="image"></p><h2 id="10-试着直接果断而不要唯唯诺诺"><a href="#10-试着直接果断而不要唯唯诺诺" class="headerlink" title="10. 试着直接果断而不要唯唯诺诺"></a>10. 试着直接果断而不要唯唯诺诺</h2><p>你可以通过不确定而颤抖的声音来表达传递自己的意思，当然也可以通过很自信的方式表达。如果你在界面中的表述用语多以问号结束，比如”也许”，”可能”，”感兴趣？” 或者”想要试试么？”，那么你完全还可以把语气变得更坚定一些。不过万事无绝对，或许适当放松措词让用户有自行思考的余地也是可以的。</p><p><img src="/assets/images/design/10.png" alt="image"></p><h2 id="11-界面要有鲜明对比让人容易区分"><a href="#11-界面要有鲜明对比让人容易区分" class="headerlink" title="11. 界面要有鲜明对比让人容易区分"></a>11. 界面要有鲜明对比让人容易区分</h2><p>把主要功能区从界面中突出显示出来效果会好很多。使你的主要口号醒目有很多种方法。通过明暗色调的对比来突显。通过为元素添加阴影渐变等效果让界面富有层次感来张显主题。最后，你甚至可以在色相环上专门选择互补色（比如黄色与紫色）来设计你的界面，以达到突出重心的目的。综合所有这些，最后得到的界面会使你的主要意图与界面其他元素有明显的区分，得到完美的呈现。</p><p><img src="/assets/images/design/11.png" alt="image"></p><h2 id="12-指明产地"><a href="#12-指明产地" class="headerlink" title="12. 指明产地"></a>12. 指明产地</h2><p>指明你的地区，所提供的服务，产品来自哪里意义重大，同时也将与客户的沟通引入了一个更具体带有地域特色的场景中。指出具体来自哪里，国家，省分及城市，也是一种在进行自我介绍或产品展示时被常常提及的。当你在界面设计中实现这点时，让人觉得非常友好。同时指明区域也会隐形提高产品的声誉，好上加好。</p><p><img src="/assets/images/design/12.png" alt="image"></p><h2 id="13-精简表单内容"><a href="#13-精简表单内容" class="headerlink" title="13. 精简表单内容"></a>13. 精简表单内容</h2><p>人生性就懒惰，在填写表单时也是同样的道理，没人愿意填写一大堆表单字段。表单中每个字段都会有失去用户的风险。不是每个人打字都很快速的，并且在移动设备上进行输入更是相当麻烦的事情。问下自己表单中是不是每个字段都必需，然后尽量减少表单中的字段。如果你确实需要一大堆信息让用户填写，试着将它们分散在不同页面，在表单提交后还可以继续补充。过多字段很容易让整个表单显示臃肿，当然想简洁也很容易，只放少数字段。</p><p><img src="/assets/images/design/13.png" alt="image"></p><h2 id="14-暴露选项而不要将操作隐藏"><a href="#14-暴露选项而不要将操作隐藏" class="headerlink" title="14. 暴露选项而不要将操作隐藏"></a>14. 暴露选项而不要将操作隐藏</h2><p>你使用的任何一个下拉框都会对用户造成信息的隐藏而需要额外的操作才能显示。如果这些信息是贯穿整个操作所必需的，那你最好把它展示出来做得更显而易见一点。下拉框最好用在选择日期，省份等约定俗成的地方。对于程序中重要的选项最好还是不要做成下拉形式。</p><p><img src="/assets/images/design/14.png" alt="image"></p><h2 id="15-把界面做得环环相扣要好过直白的排版"><a href="#15-把界面做得环环相扣要好过直白的排版" class="headerlink" title="15. 把界面做得环环相扣要好过直白的排版"></a>15. 把界面做得环环相扣要好过直白的排版</h2><p>一个平淡无奇行文无疑会让用户失去兴趣而继续阅读。是的，单列滚动的长页面是不错的，但是我们应该适当地设置一些小节，并且环环相扣，来提高用户的兴趣使其继续阅读。但需要注意的是节与节之间的留白不要太大。</p><p><img src="/assets/images/design/15.png" alt="image"></p><h2 id="16-不要放太多链接分散用户注意力"><a href="#16-不要放太多链接分散用户注意力" class="headerlink" title="16. 不要放太多链接分散用户注意力"></a>16. 不要放太多链接分散用户注意力</h2><p>为了满足各式用户的需求，在页面上放些链接链到这里链到那里是常见的做法。如果你的主要目的是想让用户点击页面最后那个下载按扭什么的话，就需要三思了。因为用户可能点击了其他链接离开页面了。所以你需要注意页面的链接数量，最好将用于导航与用于操作的链接用样式区分开。尽量移除页面不需要的链接会让用户点击到你的功能按钮。</p><p><img src="/assets/images/design/16.png" alt="image"></p><h2 id="17-将操作的状态或者进度呈现出来"><a href="#17-将操作的状态或者进度呈现出来" class="headerlink" title="17. 将操作的状态或者进度呈现出来"></a>17. 将操作的状态或者进度呈现出来</h2><p>现如今大多界面当中已经呈现了各色样式的进度条或者标明状态的图标，比如邮件有已读或未读的状态，电子帐单有支付或未支付的状态。而在界面上呈现这样的状态对于用户来说是很有必要的。这样用户就可以知道某些操作是否成功，接下来准备进行怎样的操作。</p><p><img src="/assets/images/design/17.png" alt="image"></p><h2 id="18-不要让用户觉得是在完成任务"><a href="#18-不要让用户觉得是在完成任务" class="headerlink" title="18. 不要让用户觉得是在完成任务"></a>18. 不要让用户觉得是在完成任务</h2><p>试想界面上有这样两个按钮：一个是”获取折扣”，另一个是”立即注册”。我敢打赌大多数人会点击第一个，因为第二个按扭让人感觉不到有利可图，并且”注册”让人联想到填不完的表单。也就是说让用户感受到获利的按钮更有可能被点击。这种让用户感到好处的文字信息也可放在按钮旁边，不一定要做为按钮的标题。当然，正常的按钮还是有用处的，一般用于重复性操作频繁的地方。</p><p><img src="/assets/images/design/18.png" alt="image"></p><h2 id="19-让操作直观而不是让人觉得找不到上下文"><a href="#19-让操作直观而不是让人觉得找不到上下文" class="headerlink" title="19. 让操作直观而不是让人觉得找不到上下文"></a>19. 让操作直观而不是让人觉得找不到上下文</h2><p>不用说直接在元素身上进行操作是更直观明了的方式。比如在一个列表中，我们想让用户对每个条目进行操作那么就把按钮放到当前条目上，而不要把放到列表之外。再比如就是直接点击元素就进入编辑状态（比如页面上的地址信息点击后可以进行编辑）。这种方式比传统的选中再点击相应的按钮进行操作要简洁省事得多。当然，对于一般性的操作本身就不需要有什么上下文的，就没必要这么做了，比如页面上的前进，后退按扭。</p><p><img src="/assets/images/design/19.png" alt="image"></p><h2 id="20-尽量显示全部内容而不要额外页面"><a href="#20-尽量显示全部内容而不要额外页面" class="headerlink" title="20. 尽量显示全部内容而不要额外页面"></a>20. 尽量显示全部内容而不要额外页面</h2><p>在一个足够大的宽屏界面上最好还是直接给出表单，这比点击按钮再弹出表单要好很多。首先减少了点击操作，流程变得简洁也节省了时间。其次，直接呈现出表单可以让用户知道表单有多长，其实也是在告诉用户注册花不了多少时间。当然，这条规则适合注册表单非常简单的情况。</p><p><img src="/assets/images/design/20.png" alt="image"></p><h2 id="21-让界面平滑显示而不要死板地呈现"><a href="#21-让界面平滑显示而不要死板地呈现" class="headerlink" title="21. 让界面平滑显示而不要死板地呈现"></a>21. 让界面平滑显示而不要死板地呈现</h2><p>用户进行操作过程中，界面上的元素会经常出现，隐藏，打开，关闭，放大缩小移位等。给这些元素增加些自然的动画，淡入淡出效果不但美观，也更符合实际，本来元素尺寸位置的变化就是一个需要时间的动画过程。但要注意动画时间不要设置过长，那样会让想尽快完成操作的用户不耐烦。</p><p><img src="/assets/images/design/21.png" alt="image"></p><h2 id="22-循序渐进的引导而不要直接让用户注册"><a href="#22-循序渐进的引导而不要直接让用户注册" class="headerlink" title="22. 循序渐进的引导而不要直接让用户注册"></a>22. 循序渐进的引导而不要直接让用户注册</h2><p>与其让用户马上注册，何不让用户先进行一些体验式的操作呢。这个体验过程可以展示程序的功能，特性等。一旦用户通过简单几步的操作了解了程序的价值所在，那么它会更愿意填写注册表单的。这种循序渐进的引导可以尽量推迟用户注册的时间但又可以让用户在没注册的情况下进行个性化设置等简单操作。</p><p><img src="/assets/images/design/22.png" alt="image"></p><h2 id="23-过多边框会让界面四分五裂"><a href="#23-过多边框会让界面四分五裂" class="headerlink" title="23. 过多边框会让界面四分五裂"></a>23. 过多边框会让界面四分五裂</h2><p>过多边框会喧宾夺主。不用说，边框确实在划分区域进行版块设置时有很大的作用，但同时其明显的线条也会吸引走用户的注意力。为了达到划分版块又不转移用户注意力的目的，在排版时可以将界面上不同区域的元素通过空白进行分组，用上不同的背景色，将文字对齐方式进行统一，还有就是为不同区域设置不同的样式。当使用所见即所得的界面设计工具时，我们经常在界面上方便地拖出很多区块来，这些区块多了就会显得杂乱无章。所以我们又会到处放些横线来分界。一个更好的做法是将区块垂直对齐，这样做不会让那些多余的线条来扰乱视觉。</p><p><img src="/assets/images/design/23.png" alt="image"></p><h2 id="24-展示产品带来的好处而不要罗列产品特性"><a href="#24-展示产品带来的好处而不要罗列产品特性" class="headerlink" title="24. 展示产品带来的好处而不要罗列产品特性"></a>24. 展示产品带来的好处而不要罗列产品特性</h2><p>市场就是这样的，用户永远只关心自身利益而产品特性对他们来说倒不是那么重要。只有利益才更直观地体现出使用产品所带来的价值。Chris Guillebeau在他的著作《100美元起家》中指出，相比压力，冲突，烦心事和未知的未来，人们在乎得更多的是爱，金钱，认同感和自由支配的空闲时间。所以我相信在展示产品特性时回归到利益上是必要的。</p><p><img src="/assets/images/design/24.png" alt="image"></p><h2 id="25-考虑零数据的情况"><a href="#25-考虑零数据的情况" class="headerlink" title="25. 考虑零数据的情况"></a>25. 考虑零数据的情况</h2><p>界面上经常需要呈现不同数量的数据，从0，1，10，100到10000+等。这里存在个普遍的问题就是：在程序最开始使用的0条数据到过度到有数据之前，该如何进行显示界面。这也是我们经常忽视了的地方。当程序初始没有数据时，用户看到的就是一片空白，此时用户可能不知道该进行哪些操作。利用好没有数据的初始界面可以让用户学习和熟悉如何使用程序，在程序中创建数据。力臻完美永远是我们追求的目标，界面设计也不例外。</p><p><img src="/assets/images/design/25.png" alt="image"></p><h2 id="26-默认将用户引入"><a href="#26-默认将用户引入" class="headerlink" title="26. 默认将用户引入"></a>26. 默认将用户引入</h2><p>将界面做成默认用户选中想要使用你的产品，意味着如果用户真的需要使用，那么可以直接点击确定而不需要额外点选了。当然，也有另一种做法就是默认不选中服务，用户需要的话可以手动点选。前者这种设计更好的原因有两点。一是用户不需要额外点选，非常省事，因为默认设置为用户需要我们的产品或服务。二是这种做法某种程度上是在向用户推荐产品，暗示了其他人都选择了我们。当然，将界面设计成默认选择的样子多少存在点争议，有点强迫用户的感觉。如果你想道德一点，你可以要么把让用户选择的文字写得模棱两可，要么使用双重否定这样不那么直白的描述，这两种方式都可以让用户觉得没有那么强的感觉是被强迫选择使用产品的。</p><p><img src="/assets/images/design/26.png" alt="image"></p><h2 id="27-界面设计得一致，不要增加用户的学习成本"><a href="#27-界面设计得一致，不要增加用户的学习成本" class="headerlink" title="27. 界面设计得一致，不要增加用户的学习成本"></a>27. 界面设计得一致，不要增加用户的学习成本</h2><p>自从Donald Norman的一系列著作面世后，界面设计中尽量保持一致性成了一个普遍遵循的准则。在设计中保持一致性可以减少用户的学习成本，用户不需要学习新的操作。当我们点击按钮，或者进行拖拽操作，我们期望这样的操作在整个程序的各个界面都是一致的，会得到相似的结果出来。反之我们需要新情境下重新学习某种操作会产生何种结果。可以在很多方面下功夫来实现一个一致的界面，包括颜色，方向，元素的表现形式，位置，大小，形状等。不过在让界面变得一致之前，记住一点，适当的打破整体的一致性也是可取的。这偶尔的不一致性的设计用在你需要强调的地方可以起到很大的作用。所以世事无绝对，我们应遵从一致的设计准则，但适当地打破这种常规。</p><p><img src="/assets/images/design/27.png" alt="image"></p><h2 id="28-使用较贴切的默认值会减少操作"><a href="#28-使用较贴切的默认值会减少操作" class="headerlink" title="28. 使用较贴切的默认值会减少操作"></a>28. 使用较贴切的默认值会减少操作</h2><p>适当的默认值和预先填充好的表单字段可以大量减少用户的工作量。在节省用户宝贵的时间上面，这是种非常常见的做法，可以帮助用户快速填完表单或者注册信息。</p><p><img src="/assets/images/design/28.png" alt="image"></p><h2 id="29-遵从一些约定而不要去重新设计"><a href="#29-遵从一些约定而不要去重新设计" class="headerlink" title="29. 遵从一些约定而不要去重新设计"></a>29. 遵从一些约定而不要去重新设计</h2><p>界面设计中遵从约定的准则跟之前的界面一致性准则很相似。如果我们遵从了界面设计中的一些约定，用户用起来会很方便。相反，不一致和没有遵从约定的设计则会提高学习成本。有了界面设计中这些约定，我们想都不用想就知道界面右上角（大多数情况下）的叉叉是关闭程序用的，或者点击一个按钮后我们能够预测到将会发生什么。当然，约定是会过时的，随着时间的推移，同样的操作也有可能被赋予新的含义。但要记住，当你在界面中打破这些常规时一定要目的明确，并且出发点是好的。</p><p><img src="/assets/images/design/29.png" alt="image"></p><h2 id="30-让用户觉得可以避免失去而不是获得"><a href="#30-让用户觉得可以避免失去而不是获得" class="headerlink" title="30. 让用户觉得可以避免失去而不是获得"></a>30. 让用户觉得可以避免失去而不是获得</h2><p>我们喜欢成功，没有谁愿意失败。根据心理学得到的可靠结论，人们一般更顷向于避免失去拥有的东西而不是获得新的利益。这一结论也适用于产品的设计和推广中。试着说明你的产品会帮助客户维护他的利益，保持健康，社会地位等要好过告诉客户这个产品会带来一些他未曾拥有的东西。比如保险公司，它是在销售我们出事之后可以得到的大笔赔偿呢还是在强调可以帮助我们避免失去拥有的财产？</p><p><img src="/assets/images/design/30.png" alt="image"></p><h2 id="31-具有层次的图形化展示优于直白的文字描述"><a href="#31-具有层次的图形化展示优于直白的文字描述" class="headerlink" title="31. 具有层次的图形化展示优于直白的文字描述"></a>31. 具有层次的图形化展示优于直白的文字描述</h2><p>具有层次的设计可以将界面上重要的部分与不次要部分区分开来。要让界面层次分明，可以在这些方面做文章：对齐方式，间距，颜色，缩进，字体大小，元素尺寸等。当所有这些调整运用得适当时，可以提高整个界面的可读性。相比在一个很直白的界面上用户一眼就可以从上瞟到底的设计，这样分明的设计也可以让用户放慢速度来慢慢阅读。这样也使界面更有特色一些。就好比一次旅行，你可以乘坐高铁快速到达景区（从页面顶部瞟到底部），但你也可以慢行以欣赏沿途风光。所以层次分明的设计让眼睛有可以停留的地方，而不是对着空白单调的一个屏幕。</p><p><img src="/assets/images/design/31.png" alt="image"></p><h2 id="32-将有关联的功能分组而不是杂乱无章"><a href="#32-将有关联的功能分组而不是杂乱无章" class="headerlink" title="32. 将有关联的功能分组而不是杂乱无章"></a>32. 将有关联的功能分组而不是杂乱无章</h2><p>将各个功能项分组合并起来可以提高程序的可用性。有点常识的人都知道刀子和叉子，或者打开文件和关闭文件是放在一起的。将功能相近的元素放在一起也符合逻辑，符合我们平时的认知。</p><p><img src="/assets/images/design/32.png" alt="image"></p><h2 id="33-使用内联的验证消息而不是提交后再验证"><a href="#33-使用内联的验证消息而不是提交后再验证" class="headerlink" title="33. 使用内联的验证消息而不是提交后再验证"></a>33. 使用内联的验证消息而不是提交后再验证</h2><p>在处理表单时，最好立即检测出用户所填写内容是否符合要求然后给出验证消息。这样错误一出现能就能得到改正。相反，提交后再检查表单会给出错误消息，会让用户感到乏力又要重复之前的工作。</p><p><img src="/assets/images/design/33.png" alt="image"></p><h2 id="34-放宽对用户输入的要求"><a href="#34-放宽对用户输入的要求" class="headerlink" title="34. 放宽对用户输入的要求"></a>34. 放宽对用户输入的要求</h2><p>对用户输入的数据，尽量放宽限制，包括格式，大小写什么的。这样做可以更人性化一点，也使得界面更加友好。一个再恬当不过的例子就是让用户输入电话号码的时候，用户有很多种输入方式，带括号的，带破折号的，带空格的，带区号和不带区号的等等。如果你在代码中来处理这些格式的问题，代价也只是你一个人多写几行代码而以，却可以减少无数用户的工作量。</p><p><img src="/assets/images/design/34.png" alt="image"></p><h2 id="35-让用户感觉需要快速做出响应而不是毫无时间观念"><a href="#35-让用户感觉需要快速做出响应而不是毫无时间观念" class="headerlink" title="35. 让用户感觉需要快速做出响应而不是毫无时间观念"></a>35. 让用户感觉需要快速做出响应而不是毫无时间观念</h2><p>适当的紧迫感是个有效的战术可以让用户立即做出决定而不是等上个十天半个月。重要的是这种战术屡试不爽，因为它暗示了资源的紧缺或者活动的时间有限，今天可以买，但明天可能就无法这么低价了。另一方面，这一战术也让用户感到会错失一次大好的机会，再一次，应用了人们害怕失去的本性。当然，这种战术会被一些人嗤之以鼻，认为是不耿直的做法。不过，这只是种战术而以，并且在保持合法性的前提下应用也无伤大雅。所以请不要为了营销而在界面上制造紧迫的假象。</p><p><img src="/assets/images/design/35.png" alt="image"></p><h2 id="36-使用饥饿营销"><a href="#36-使用饥饿营销" class="headerlink" title="36. 使用饥饿营销"></a>36. 使用饥饿营销</h2><p>物以稀为贵。饥饿营销给出的信息就是东西不多，只剩几件，明天再来，可能没了。你去比较一下批发与限量版的东西他们的价格差距有多大就知道了。回过头来看，那些批发商或者大零售商，他们也使用饥饿营销，以获得更好的销量。但在软件行业，我们经常会忘记有饥饿营销这回事。因为数字产品是可以很容易拷贝复制的，不存在缺货的情况。其实，在界面设计中，也可以将其运用起来与现实中的资源紧缺进行联系。想想一次网上研讨会的门票，想想你一个月可以服务的人数限制，这些信息都可以告知用户是有限的。</p><p><img src="/assets/images/design/36.png" alt="image"></p><h2 id="37-让用户选择而不是重新填写"><a href="#37-让用户选择而不是重新填写" class="headerlink" title="37. 让用户选择而不是重新填写"></a>37. 让用户选择而不是重新填写</h2><p>这一界面设计中的经典准则是有心理学依据的，相比要让某人回想想某样东西，从一堆东西中认出某样东西会更容易些。辨识出一样东西只需要我们稍微回忆一下，通过一些线索就可以完成。而回想则需要我们全面搜索自己的大脑。也许这也是为什么试卷上选择题会比简答题做得快的原因。所以试着在界面上展示一些用户之前涉及到的信息让他们进行选择，而不是让他们想半天然后自己填写。</p><p><img src="/assets/images/design/36.png" alt="image"></p><h2 id="38-让点击更轻松"><a href="#38-让点击更轻松" class="headerlink" title="38. 让点击更轻松"></a>38. 让点击更轻松</h2><p>像链接，表单的输入框还有按钮等，如果尺寸做得大一点则点击起来更方便容易些。根据费特定律，使用像鼠标这样的外设来点击需要一些时间，特别是元素比较小的情况下，时间会更多。鉴于此，最好还是把你的表单输入框，按钮等做大点。抑或者你可以保持原有的设计不变，只是把元素可点击区域（也就是热区）增大。这样的一个典型例子是手机设备上的文本链接和导航菜单，它们文字不一定很大但背景是拉伸的，在很宽范围内点击都有效。</p><p><img src="/assets/images/design/38.png" alt="image"></p><h2 id="39-优化页面加载速度，不要让用户等太久"><a href="#39-优化页面加载速度，不要让用户等太久" class="headerlink" title="39. 优化页面加载速度，不要让用户等太久"></a>39. 优化页面加载速度，不要让用户等太久</h2><p>速度很重要。页面加载速度和UI对操作的响应速度都直接关系到用户是否有耐心继续等下去。无疑地每多一秒种的等待都会失去一些用户或者项目机会。一个好的解决之道当然就是优化你的页面和图片。除此之外还可以运用心理学让这个等待时间显得不那么长。具体来说有两种技巧。一是显示进度条，二是展示其他相关或有趣的东西来吸引用户的注意力（就好比你沿着传送带走走总比傻站在原地盯着一个位置看要好得多吧）。</p><p><img src="/assets/images/design/39.png" alt="image"></p><h2 id="40-除了按扭外，快捷键也必不可少"><a href="#40-除了按扭外，快捷键也必不可少" class="headerlink" title="40. 除了按扭外，快捷键也必不可少"></a>40. 除了按扭外，快捷键也必不可少</h2><p>当你的程序广为流传，应该考虑下高级用户的感受。人们总是试图为一些重复性的操作找到更快捷的方法，快捷键就应运而生了。相比在界面上点来点去，快捷键无疑大大提高工作效率。一个好的例子就是现今流行于各个主流程序中的J（后退）K（前进）快捷键组合，比如在Gmail，Twitter和Tumblr中。按钮固然好，但快捷键会锦上添花。</p><p><img src="/assets/images/design/40.png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好的用户界面-界面设计的一些技巧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以下内容转自：&lt;a href=&quot;https://www.cnblogs.com/Wayou/p/goodui.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/Wayou/p/goodui.html&lt;/a&gt;&lt;br&gt;&lt;br&gt;英文原文地址：&lt;a href=&quot;https://goodui.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://goodui.org/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="转载" scheme="http://yoursite.com/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="交互" scheme="http://yoursite.com/tags/%E4%BA%A4%E4%BA%92/"/>
    
      <category term="UI" scheme="http://yoursite.com/tags/UI/"/>
    
  </entry>
  
  <entry>
    <title>从输入URL到页面加载完成的过程</title>
    <link href="http://yoursite.com/2018/06/url-loading-process/"/>
    <id>http://yoursite.com/2018/06/url-loading-process/</id>
    <published>2018-06-06T12:11:00.000Z</published>
    <updated>2020-01-13T07:44:08.175Z</updated>
    
    <content type="html"><![CDATA[<p>其实这种问题网络上有很多，但是每篇文章各有千秋，而我写这篇文章，也是想仔细缕一缕这个过程，让自己更深刻的理解。</p><a id="more"></a><h2 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h2><h3 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h3><p>为了准确无误地将数据送达目标处，<strong>TCP</strong>协议采用了三次握手策略。用<strong>TCP</strong>协议把数据包送出去后，<strong>TCP</strong>不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。</p><p>首先我们要先了解下TCP/IP协议族的分层管理</p><p>TCP/IP协议族按层次分别分为：<strong>应用层、传输层、网络层和数据链路层</strong></p><ul><li>应用层：应用层决定了向用户提供应用服务时通信的活动。<strong>DNS服务、HTTP协议</strong>存在该层。(<a href="/2017/10/web-url/" title="HTTP协议可以查看我写的另外一篇文章">HTTP协议可以查看我写的另外一篇文章</a>)</li><li>传输层：提供处于网络连接中的两台计算机之间的数据传输。</li><li>网络层： 网络层用来处理在网络上流动的数据包。</li><li>链路层： 用来处理连接网络的硬件部分。</li></ul><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>DNS域名解析,说得简单点就是将好记的域名解析成IP，服务由DNS服务器完成，是把域名解析到一个IP地址，然后在此IP地址的主机上将一个子目录与域名绑定。互联网中的地址是数字的IP地址，域名解析的作用主要就是为了便于记忆。</p><h2 id="过程分析"><a href="#过程分析" class="headerlink" title="过程分析"></a>过程分析</h2><ol><li>浏览器查找域名对应的<strong>IP</strong>地址（DNS解析）</li><li>HTTP协议生成<strong>HTTP</strong>请求报文。</li><li>客户端与服务器建立<strong>TCP</strong> 连接（三次握手🤝）。</li><li>浏览器向服务器发送HTTP请求。</li><li>浏览器拿到服务端响应内容，解码、渲染。</li><li>解析html为DOM Tree，解析css为CSS Tree。</li><li>DOM + CSS生成render-tree绘图。</li><li>加载script的js文件，执行js。</li><li>通讯完成关闭<strong>TCP</strong>连接（四次挥手👋）</li></ol><p><strong>每个过程中间还会发生很多事情，下面单独分析每个过程发生的细节</strong></p><h3 id="1-浏览器查找域名对应的IP地址"><a href="#1-浏览器查找域名对应的IP地址" class="headerlink" title="1.浏览器查找域名对应的IP地址"></a>1.浏览器查找域名对应的IP地址</h3><p><strong>DNS服务</strong></p><blockquote><p>DNS服务是和HTTP协议位于应用层的协议。它提供域名到IP地址之间的解析服务。</p></blockquote><h4 id="1-1-DNS查询"><a href="#1-1-DNS查询" class="headerlink" title="1.1 DNS查询"></a>1.1 DNS查询</h4><p>操作系统会先检查本地hosts文件是否有这个网址映射关系，如果有就调用这个IP地址映射，完成域名解析。</p><p>否则，查找本地<strong>DNS</strong>解析器缓存，如果查找到则返回。</p><p>否则，查找本地<strong>DNS</strong>服务器，如果查找到则返回。</p><p>否则，则发起一个递归<strong>DNS</strong>解析请求，一层一层逐级向上查询找到IP地址。</p><p><strong>补充</strong><br>这里是有缓存相关的知识，涉及浏览器缓存、DNS缓存，缓存内容的有效性决定是否需要发送HTTP请求。在这里不在细说。</p><h3 id="2-HTTP协议生成HTTP请求报文"><a href="#2-HTTP协议生成HTTP请求报文" class="headerlink" title="2.HTTP协议生成HTTP请求报文"></a>2.HTTP协议生成HTTP请求报文</h3><p>HTTP协议生成针对目标 Web 服务器的 HTTP 请求报文，请求报文由<strong>请求行、请求头部、数据体</strong>3个部分组成。</p><h3 id="3-客户端与服务器建立TCP连接"><a href="#3-客户端与服务器建立TCP连接" class="headerlink" title="3.客户端与服务器建立TCP连接"></a>3.客户端与服务器建立TCP连接</h3><p>拿到了服务器的 IP 地址以及 HTTP 请求报文，就开始与服务器建立 TCP 连接了。</p><h4 id="3-1-三次握手🤝（SYN-SYN-ACK-ACK）"><a href="#3-1-三次握手🤝（SYN-SYN-ACK-ACK）" class="headerlink" title="3.1 三次握手🤝（SYN,SYN/ACK,ACK）"></a>3.1 三次握手🤝（SYN,SYN/ACK,ACK）</h4><p><img src="/assets/images/url-three-handshake.jpg" alt="三次握手"></p><ol><li>客户端把标有<strong>SYN</strong>的数据包发给服务器</li><li>服务器接收到客户端的数据包，并发送标有<strong>SYN/ACK</strong>的数据包给客户端。</li><li>客户端接收到服务器发送的数据包后，再发送标有<strong>ACK</strong>的数据包给服务器。</li></ol><p>这样，客户端与服务器两者就建立了连接。</p><h3 id="4-浏览器向服务器发送HTTP请求"><a href="#4-浏览器向服务器发送HTTP请求" class="headerlink" title="4.浏览器向服务器发送HTTP请求"></a>4.浏览器向服务器发送HTTP请求</h3><p><strong>一个HTTP请求过程如下：</strong></p><ol><li>客户端在应用层（HTTP协议）发出一个<strong>HTTP</strong>请求。</li><li>在传输层（TCP协议）把从应用层处收到的数据（HTTP请求报文）进行分割，并在各个报文上打上标记序号及端口号后转发给网络层。</li><li>在网络层（IP协议），增加作为通信目的地的MAC地址后转发给链路层。这样一来，发往网络的通信请求就准备齐全了。</li><li>接收端的服务器在链路层接受到数据，按序往上层发送，一直到应用层。当传输到应用层时，才能算真正接收到由客户端发送过来的<strong>HTTP</strong>请求。</li><li>服务器请求的处理结果也同样利用 TCP/IP 通信协议向客户端进行回传。</li></ol><p>数据经过应用层、传输层、网络层、链路层逐层封装，传输到下一个目的地。</p><p>然后接着从链路层得到数据后逐层的解包，最终将数据发送服务端。</p><h3 id="5-浏览器拿到服务端响应内容，解码、渲染"><a href="#5-浏览器拿到服务端响应内容，解码、渲染" class="headerlink" title="5.浏览器拿到服务端响应内容，解码、渲染"></a>5.浏览器拿到服务端响应内容，解码、渲染</h3><h4 id="5-1-解码"><a href="#5-1-解码" class="headerlink" title="5.1 解码"></a>5.1 解码</h4><p>浏览器拿到服务端响应的内容后，开始解析其中的html文件，遇到js/css/img等资源连接，就向服务器端去请求下载</p><h4 id="5-2-渲染"><a href="#5-2-渲染" class="headerlink" title="5.2 渲染"></a>5.2 渲染</h4><p>浏览器根据html、css、js渲染DOM树，绘制等。</p><h3 id="6-关闭TCP连接（四次挥手👋）"><a href="#6-关闭TCP连接（四次挥手👋）" class="headerlink" title="6.关闭TCP连接（四次挥手👋）"></a>6.关闭TCP连接（四次挥手👋）</h3><ol><li>客户端向服务器端发送一个<strong>FIN</strong>，请求关闭数据传输。</li><li>服务器接收到客户端的<strong>FIN</strong>时，向客户端发送一个<strong>ACK</strong>。（表示收到）</li><li>然后服务器向客户端发送一个<strong>FIN</strong>。（告诉客户端准备就绪，可以关闭）</li><li>客户端收到服务器端的<strong>FIN</strong>时，发送<strong>ACK</strong>给服务器端，并断开连接。（反馈确认信号给服务器）</li></ol><p><strong>补充说明</strong></p><ol><li>服务器在接到断开请求时不立即同意断开：因为服务器接收到断开请求时，只能说明客户端没有数据需要获取了，但是可能存在服务器还有未发送完毕的数据，所以要等服务器先发送确认信号，所以数据传输完毕后再同意断开。</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>《图解HTTP》<br>《HTTP权威指南》</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实这种问题网络上有很多，但是每篇文章各有千秋，而我写这篇文章，也是想仔细缕一缕这个过程，让自己更深刻的理解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="URL" scheme="http://yoursite.com/tags/URL/"/>
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>Web安全基础</title>
    <link href="http://yoursite.com/2018/05/webSafety/"/>
    <id>http://yoursite.com/2018/05/webSafety/</id>
    <published>2018-05-29T08:11:00.000Z</published>
    <updated>2019-12-20T01:23:06.146Z</updated>
    
    <content type="html"><![CDATA[<p>Web安全主要分为客户端和服务器，文章主要讲述Web安全相关知识，从中可以了解到各种各样的攻击方式，对所有的安全问题有一定的认识和见解，对开发者开发时有一定的思考。</p><a id="more"></a><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><ul><li>XSS</li><li>CSRF</li><li>点击劫持</li><li>URL跳转</li><li>…</li></ul><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><blockquote><p>下面讲解XSS相关知识内容。</p></blockquote><h4 id="什么是XSS"><a href="#什么是XSS" class="headerlink" title="什么是XSS"></a>什么是XSS</h4><p>XSS叫做（Cross Site Script）跨站脚本。</p><p>黑客通过“HTML注入”篡改网页，<strong>插入恶性脚本</strong>，当用户在浏览网页时，实现控制用户浏览器行为的一种攻击方式。</p><p>常见的危害有：盗取用户信息，钓鱼，制作蠕虫等。</p><h4 id="XSS分类"><a href="#XSS分类" class="headerlink" title="XSS分类"></a>XSS分类</h4><blockquote><p>存储型</p></blockquote><ol><li>黑客通过恶意构造XSS脚本，提交给Web应用程序，把恶意数据写入到数据库中。</li><li>当用户访问Web应用时，前端从后端获取到恶意数据并在HTML里渲染。触发XSS脚本，从而盗取用户信息、冒充用户行为等操作。</li></ol><p>常见实例，黑客通过Web应用留言回复功能插入XSS脚本，当其他用户访问查看时即触发脚本代码。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--图片src加载错误，执行onerror函数触发脚本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"#"</span> <span class="attr">onerror</span>=<span class="string">"脚本代码"</span> &gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>反射型</p></blockquote><ol><li>黑客通过邮箱、分享等方式让用户访问携带XSS脚本的链接进入Web应用。</li><li>Web程序解析请求参数响应到浏览器，从而触发XSS脚本。（前后端不分离时常见）。</li></ol><blockquote><p>DOM型</p></blockquote><p>DOM型XSS和反射性XSS基本上是一样的，DOM型XSS是通过前端js将XSS脚本插入到DOM里（innterHTML）。比如把url上的锚点参数输出到html，从而触发XSS</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><table><thead><tr><th>XSS类型</th><th>存储型</th><th>反射型</th><th>DOM型</th></tr></thead><tbody><tr><td>触发过程</td><td>黑客构造XSS脚本,用户访问携带XSS脚本的页面</td><td>用户访问携带XSS脚本的页面</td><td>用户访问携带XSS脚本的页面</td></tr><tr><td>数据存储</td><td>数据库</td><td>URL</td><td>URL</td></tr><tr><td>输出类型</td><td>后端服务器</td><td>后端服务器</td><td>前端js</td></tr><tr><td>输出位置</td><td>HTTP响应中</td><td>HTTP响应中</td><td>动态构造的DOM节点</td></tr></tbody></table><ol><li>DOM型XSS和反射型XSS的区别</li></ol><ul><li><p>DOM型XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 js 自身的安全漏洞。</p></li><li><p>反射型XSS 攻击中，取出和执行恶意代码由服务端完成，服务端的安全漏洞。</p></li></ul><ol start="2"><li>XSS攻击主要是web1时代里经常遇到的漏洞，但是在目前前后端分离的情况下。前端使用MVVM框架编写应用时，对用是否渲染html都会特别注意。（<strong>一般只在可信的内容上使用</strong>）</li></ol><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><blockquote><p>下面讲解CSRF相关知识内容。</p></blockquote><h4 id="什么是CSRF"><a href="#什么是CSRF" class="headerlink" title="什么是CSRF"></a>什么是CSRF</h4><p>CSRF叫做（Cross-site request forgery）跨站请求伪造。</p><p>利用用户已登录的身份，在用户毫不知情的情况下，以用户的名义完成非法操作。常见的危害有：执行恶意操作（被转账、被发垃圾评论）等。</p><blockquote><p>正常转账过程</p></blockquote><ol><li>用户正常登录账号</li><li>通过请求转账接口进行转账</li><li>浏览器发送请求时，会自动带上Cookie及请求参数（收款人信息）</li><li>服务端通过Cookie识别用户身份、从参数获取到收款人信息，执行转账操作</li></ol><blockquote><p>异常转账过程（攻击）</p></blockquote><ol><li>用户正常登陆账号</li><li>黑客通过各种方式让用户访问构造恶意页面</li><li>恶意页面请求转账接口进行转账，盗用用户Cookie及伪造收款人信息</li><li>服务端通过Cookie识别用户身份、从参数获取到收款人信息，执行转账操作</li></ol><h4 id="防范"><a href="#防范" class="headerlink" title="防范"></a>防范</h4><ol><li>使用post请求，限制get请求（作用不大）</li><li>将cookie设置为HttpOnly，避免攻击者伪造cookie的情况出现</li><li>增加token校验</li><li>通过Referer识别请求来源地址。</li><li>跨域拦截。</li></ol><h3 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h3><blockquote><p>下面讲解点击劫持相关知识内容。</p></blockquote><p>通过覆盖不可见的框架(iframe)误导用户点击而造成的攻击行为。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>隐蔽性比较高</li><li>骗取用户操作</li><li>UI-覆盖攻击</li><li>利用了iframe或者其他标签的属性（Flash）</li></ul><h3 id="URL跳转"><a href="#URL跳转" class="headerlink" title="URL跳转"></a>URL跳转</h3><blockquote><p>下面讲解URL跳转相关知识内容。</p></blockquote><p>借助未验证的URL跳转，将应用程序引导到不安全的第三方页面（攻击者），从而导致的安全问题。</p><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><ul><li>Header头跳转（通过设置响应头的Location）</li><li>JavaScript跳转（window.location.href）</li><li><meta>标签跳转（<meta http-equiv="Rrefresh" url="url...">）</li></ul><p><strong>流程</strong></p><ol><li>黑客构造恶意链接（具有迷惑性如<a href="http://www.baidu.com??url=恶意链接）" target="_blank" rel="noopener">www.baidu.com??url=恶意链接）</a></li><li>用户访问黑客构造链接</li><li>用户被引导进入恶意网站</li></ol><hr><h2 id="服务端安全问题"><a href="#服务端安全问题" class="headerlink" title="服务端安全问题"></a>服务端安全问题</h2><ul><li>SQL注入</li><li>命令注入</li><li>文件操作类</li><li>…</li></ul><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><blockquote><p>下面讲解SQL注入相关知识内容。</p></blockquote><h4 id="什么是SQL注入"><a href="#什么是SQL注入" class="headerlink" title="什么是SQL注入"></a>什么是SQL注入</h4><p>SQL注入叫做（SQL Injection）</p><p>是一种常见的Web安全漏洞，攻击者利用这个漏洞，可以访问或修改数据，利用潜在的数据库漏洞进行攻击。</p><blockquote><p>过程</p></blockquote><ol><li>服务端获取用户请求参数</li><li>拼接到代码当中</li><li>SQL语句按照我们构造参数的语义执成功</li></ol><h4 id="SQL注入的本质"><a href="#SQL注入的本质" class="headerlink" title="SQL注入的本质"></a>SQL注入的本质</h4><p><strong>数据和代码</strong>未分离，既<strong>数据当做了代码</strong>来执行</p><h4 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h4><blockquote><p>获取数据库信息</p></blockquote><ul><li>管理员后台账号和密码</li><li>获取其他数据库敏感数据</li><li>整个数据库：</li><li>获取服务器权限</li><li>植入Webshell，获取服务器后门</li><li>读取服务器敏感文件</li></ul><h3 id="命令注入"><a href="#命令注入" class="headerlink" title="命令注入"></a>命令注入</h3><blockquote><p>下面讲解命令注入相关知识内容。</p></blockquote><h4 id="命令注入满足三个条件"><a href="#命令注入满足三个条件" class="headerlink" title="命令注入满足三个条件"></a>命令注入满足三个条件</h4><ol><li>调用可执行系统命令的函数</li><li>函数或函数的参数可控</li><li>拼接注入命令</li></ol><h4 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h4><ol><li>黑客构造命令发送给服务端</li><li>服务端拼接命令执行注入的命令</li><li>服务端把命令执行的结果响应到黑客</li></ol><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>《Web白帽子》</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Web安全主要分为客户端和服务器，文章主要讲述Web安全相关知识，从中可以了解到各种各样的攻击方式，对所有的安全问题有一定的认识和见解，对开发者开发时有一定的思考。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
      <category term="Web漏洞" scheme="http://yoursite.com/tags/Web%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS原理理解</title>
    <link href="http://yoursite.com/2018/04/https/"/>
    <id>http://yoursite.com/2018/04/https/</id>
    <published>2018-04-05T08:11:00.000Z</published>
    <updated>2019-12-20T01:22:40.525Z</updated>
    
    <content type="html"><![CDATA[<p>在HTTP协议中可能存在信息窃听或身份伪装等安全问题，使用HTTPS通信机制可以有效地防止这些问题。这篇文章会先从HTTP的缺点开始讲述，从而引申出HTTPS的功能以及重要性。</p><a id="more"></a><h2 id="HTTP的缺点"><a href="#HTTP的缺点" class="headerlink" title="HTTP的缺点"></a>HTTP的缺点</h2><ul><li>通信使用明文，内容可能会被窃听。</li><li>不验证通信方的身份，因此有可能遭遇伪装。</li><li>无法证明报名的完整性，所以有可能已遭篡改。</li></ul><p>为了有效防止这些弊端，为了保证数据安全，所有<strong>HTTPS</strong>就派上用场了。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul><li><strong>TLS</strong>：(Transport Layer Security，传输层安全协议)，用于两个应用程序之间提供保密性和数据完整性。其前身是SSL。</li><li><strong>SSL</strong>：（Secure Socket Layer，安全套接字层）：1994年为 Netscape 所研发，SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。</li></ul><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>HTTPS并非是应用层的一种新协议，只是HTTP通信接口部分用SSL和TLS协议代替。</p><p>一般情况，HTTP直接和TCP通信，当使用SSL时，则变成先和SSL通信，再由SSL和TCP通信。</p><ul><li><strong>HTTP</strong>：HTTP应用–&gt;TCP–&gt;IP</li><li><strong>HTTPS</strong>：HTTP应用–&gt;SSL–&gt;TCP–&gt;</li></ul><h2 id="加密技术"><a href="#加密技术" class="headerlink" title="加密技术"></a>加密技术</h2><p>对SSL讲解之前，先简单了解一下加密方法。SSL采用一种叫做公开密钥加密的加密处理方式。</p><p>近代的加密方式中加密算法是公开的，而密钥是保密的，通过这种方式得以保证加密方法的安全性。</p><p>加密和解密都会用到密钥。没有密钥就无法对密钥解密，反过来说，任何人只要持有密钥就能解密了。如果密钥被攻击者获取，那加密也就失去了意义。</p><h3 id="共享密钥加密的问题"><a href="#共享密钥加密的问题" class="headerlink" title="共享密钥加密的问题"></a>共享密钥加密的问题</h3><p>加密和解密同用一个密钥的方式称为共享密钥加密，也叫<strong>对称密钥加密</strong></p><p>在HTTP请求中，发送密钥就会有被窃听的风险，但不发送，对方就不能解密。如果密钥能安全发送，那数据也应该能安全送达。</p><h3 id="使用两把密钥的公开密钥加密"><a href="#使用两把密钥的公开密钥加密" class="headerlink" title="使用两把密钥的公开密钥加密"></a>使用两把密钥的公开密钥加密</h3><p>公开密钥加密方式解决了共享密钥加密的困难，<br>公开密钥加密使用一对非对称的密钥。（私有密钥和公开密钥）</p><blockquote><p>私有密钥：只有自己知道，其他任何人都不能知道。</p></blockquote><blockquote><p>公开密钥：公开密钥可以随意发布，任何人都可以获得。</p></blockquote><p><strong>使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。</strong></p><h3 id="HTTPS采用混合加密机制"><a href="#HTTPS采用混合加密机制" class="headerlink" title="HTTPS采用混合加密机制"></a>HTTPS采用混合加密机制</h3><p>原因：公开密钥加密处理起来比共享密钥加密方式更为复杂，若在通信时使用公开密钥加密方式，效率会很低。</p><p>HTTPS采用共享密钥加密和公开密钥加密两者并用的混合加密机制。<strong>在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式</strong>。</p><p><img src="/assets/images/https-encrypt.jpg" alt="HTTPS混合加密机制"></p><h3 id="SSL证书"><a href="#SSL证书" class="headerlink" title="SSL证书"></a>SSL证书</h3><p>公开密钥加密方式还是存在一些问题。那就是无法证明公开密钥本身就是货真价实的公开密钥。或许公开密钥在传输过程中，真正的公开密钥已经被攻击者替换掉了。</p><p>解决上述问题，可以使用由数字证书认证机构（CA，Certificate Authority）和其他相关机关颁发的公开密钥证书。数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。</p><p>通俗的讲：服务器自身发行的公开密钥没有权威性，无法证明公开密钥是自身发行的。</p><ol><li>那么假设有一个权威的第三方认证机构，服务器向数字证书认证机构提出公开密钥的申请。</li><li>数字证书认证机构对申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，将该公开密钥放入公钥证书后绑定在一起。（服务器得到一个证书）</li><li>服务器将这份由数字证书认证机构颁发的公钥证书发送给客户端，进行公开密钥加密方式通信。</li><li>接到证书的客户端使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证。如果验证通过，则说明服务器的公开密钥是可信的。</li></ol><p>补充：<br>此处认证机关的公开密钥必须安全地转交给客户端。所以大多数浏览器在发布版本时，会先在内部植入常用的认证机关的公开密钥。（不需要传输）</p><h3 id="HTTPS安全通信机制"><a href="#HTTPS安全通信机制" class="headerlink" title="HTTPS安全通信机制"></a>HTTPS安全通信机制</h3><p>HTTPS使用SSL和TLS这两个协议。<br>下面是HTTPS通信步骤</p><ol><li>客户端通过发送<strong>Client Hello</strong>报文开始SSL通信。报文中包含客户端支持的SSL指定版本、加密组件列表等。</li><li>服务器可进行SSL通信时，会以Server Hello报文作为应答。和客户端一样，在报文中包含SSL版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。</li><li>之后服务器发送<strong>Certificate</strong>报文，报文中包含公开密钥证书。</li><li>最后服务器发送**Server Hello Done报文通知客户端，最初阶段的SSL握手协商部分完成。</li><li>SSL第一次握手结束后，客户端以<strong>Client Key Exchange</strong>报文作为回应。报文中包含通信加密中使用的一种被称为<strong>Pre-master secret</strong>的随机密码串。该报文已用第三步的公开密钥进行加密。</li><li>接着客户端继续发送<strong>Change Cipher Spec</strong>报文。该报文会提示服务器，在此报文之后的通信会采用<strong>Pre-master secret</strong>密钥加密。</li><li>客户端发送<strong>Finished</strong>报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文座位判定标准。</li><li>服务器同样发送<strong>Change Cipher Spec</strong>报文。</li><li>服务器同样发送<strong>Finished</strong>报文。</li><li>服务器和客户端的Finished报文交换完毕之后，SSL链接就算建立完成。当然，通信会受到SSL的保护。从此处开始进行应用层协议的通信，发送HTTP请求。</li></ol><p>通俗理解：</p><ol><li>客户端使用https的url访问web服务器,要求与服务器建立ssl连接</li><li>web服务器收到客户端请求后, 会将网站的证书(包含公钥)传送一份给客户端</li><li>客户端收到网站证书后会检查证书的颁发机构以及过期时间, 如果没有问题就随机产生一个秘钥</li><li>客户端利用公钥将会话秘钥加密, 并传送给服务端, 服务端利用自己的私钥解密出会话秘钥</li><li>之后服务器与客户端使用秘钥加密传输</li></ol><p>总结：相比HTTP协议，HTTPS 协议增加了很多握手、加密解密等流程，虽然过程很复杂，但其可以保证数据传输的安全。为了保证数据的安全，很有必要使用HTTPS。</p><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>《图解HTTP》<br>《HTTP权威指南》</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在HTTP协议中可能存在信息窃听或身份伪装等安全问题，使用HTTPS通信机制可以有效地防止这些问题。这篇文章会先从HTTP的缺点开始讲述，从而引申出HTTPS的功能以及重要性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
      <category term="安全" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="SSL/TLS" scheme="http://yoursite.com/tags/SSL-TLS/"/>
    
      <category term="HTTPS" scheme="http://yoursite.com/tags/HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 函数节流和函数去抖</title>
    <link href="http://yoursite.com/2018/02/js-throttle-debounce/"/>
    <id>http://yoursite.com/2018/02/js-throttle-debounce/</id>
    <published>2018-02-05T08:11:00.000Z</published>
    <updated>2019-12-20T01:22:15.434Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 函数节流和函数去抖</p><a id="more"></a><p>防抖（<strong>debounce</strong>）和节流（<strong>throttle</strong>）都是用来控制某个函数在一定时间内执行多少次，从而实现性能优化。</p><h2 id="节流（throttle）"><a href="#节流（throttle）" class="headerlink" title="节流（throttle）"></a>节流（throttle）</h2><p><strong>定义</strong>：是指连续触发事件但是在 n 秒中只执行一次函数。节流会稀释函数的执行频率。</p><h2 id="去抖（debounce）"><a href="#去抖（debounce）" class="headerlink" title="去抖（debounce）"></a>去抖（debounce）</h2><p><strong>定义</strong>：就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>在开发过程中，会遇到处理频率很高的事件或着连续的事件，比如像<strong>window</strong>的<strong>resize/scroll</strong> 事件调用某个函数A。</p><p>如果不进行处理，这个时候伴随着resize 就会执行无数个函数A ,若函数 是个很复杂的函数，需要较多的运算执行时间，响应速度跟不上触发频率，往往会出现延迟，导致假死或者卡顿感，并且很多情况下并不是需要“如此”夸张的频繁调用函数A。</p><p><strong>1.针对scroll方法写一个例子。（假设时间间隔2s)</strong></p><ul><li>节流（throttle）：在<strong>scroll</strong>的过程中，每隔2s执行一次函数 A；</li><li>去抖（debounce）：在<strong>scroll</strong>结束之后，过了2s ，执行一次函数A，如果没有到2s ，就又开始scroll ，那么就重新计时，并不执行函数A。（一定时间段内只执行一次）。</li></ul><p><strong>2.节流（throttle）和 去抖（debounce） 的应用场景应该是分的很清楚的</strong></p><ul><li>按一个按钮发送 AJAX：给 click 加了 debounce 后就算用户不停地点这个按钮，也只会最终发送一次；如果是 throttle 就会间隔发送几次</li><li>监听滚动事件判断是否到页面底部自动加载更多：给 scroll 加了 debounce 后，只有用户停止滚动后，才会判断是否到了页面底部；如果是 throttle 的话，只要页面滚动就会间隔一段时间判断一次。</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><h5 id="throttle-应用场景"><a href="#throttle-应用场景" class="headerlink" title="throttle 应用场景"></a>throttle 应用场景</h5><ul><li>DOM 元素的拖拽功能实现（mousemove）</li><li>射击游戏的 mousedown/keydown 事件（单位时间只能发射一颗子弹）</li><li>计算鼠标移动的距离（mousemove）</li><li>Canvas 模拟画板功能（mousemove）</li><li>监听滚动事件判断是否到页面底部自动加载更多：给 scroll 加了 debounce 后，只有用户停止滚动后，才会判断是否到了页面底部；如果是 throttle 的话，只要页面滚动就会间隔一段时间判断一次。</li></ul><h5 id="debounce-应用场景"><a href="#debounce-应用场景" class="headerlink" title="debounce 应用场景"></a>debounce 应用场景</h5><ul><li>AutoComplete中的Ajax请求使用的keypress。</li><li>文本输入的验证（连续输入文字后发送 AJAX 请求进行验证，验证一次就好）。</li></ul><h2 id="underscore-js使用"><a href="#underscore-js使用" class="headerlink" title="underscore.js使用"></a>underscore.js使用</h2><p><em>underscore.js是一个很精干的库，压缩后只有5.2KB。它提供了几十种函数式编程的方法，弥补了标准库的不足，大大方便了JavaScript的编程</em></p><p>underscore.js封装好的去抖和节流是考虑了高级配置的下面我们来看看如何使用。</p><h5 id="1-throttle方法："><a href="#1-throttle方法：" class="headerlink" title="1. throttle方法："></a>1. throttle方法：</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _.throttle( function, wait, options )</span></span><br><span class="line"><span class="comment">// 使用实例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每隔250毫秒触发一次</span></span><br><span class="line">$(<span class="built_in">window</span>).scroll( _.throttle( doSomething, <span class="number">250</span> ) )</span><br></pre></td></tr></table></figure><p>underscore.js中针对这个方法接收三个参数：</p><ol><li>function即你要在密集事件内调用的函数。</li><li>wait 即时间间隔。</li><li>options 可以传两种选项。</li></ol><blockquote><p>{ leading: false }，表示scroll开始的那次回调会被忽略。</p></blockquote><blockquote><p>如果不传，就表示scroll开始的时候会触发function，scroll停止后还会触发一次function。</p></blockquote><blockquote><p>{ trailing: false }，表示scroll结束后的那次回调会被忽略。</p></blockquote><h5 id="2-debounce方法："><a href="#2-debounce方法：" class="headerlink" title="2. debounce方法："></a>2. debounce方法：</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _.debounce( function, wait, immediate )</span></span><br><span class="line"><span class="comment">// 使用实例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当用户停顿250毫秒以后才开始执行</span></span><br><span class="line">$(<span class="built_in">window</span>).scroll( _.debounce( doSomething, <span class="number">250</span> ) )</span><br></pre></td></tr></table></figure><p>underscore.js中针对这个方法接收三个参数：</p><ol><li>function即你要在密集事件内调用的函数。</li><li>wait 即时间间隔。</li><li>immediate可以传true或者false。传为true，会在时间间隔的开始调用这个函数 （注：并且在 waite 的时间之内，不会再次调用）。在类似不小心点了提交按钮两下而提交了两次的情况下很有用。</li></ol><blockquote><p>true，表示scroll开始时即调用这个函数。（并且在 waite 的时间之内，不会再次调用，即触发于开始边界）。</p></blockquote><blockquote><p>false（不传），触发于结束边界。</p></blockquote><h3 id="underscore源码注解"><a href="#underscore源码注解" class="headerlink" title="underscore源码注解"></a>underscore源码注解</h3><p>基于开发版本（1.7.0）的源码，加上了一些注释以帮助理解。</p><h5 id="throttle-方法源码"><a href="#throttle-方法源码" class="headerlink" title="_.throttle 方法源码"></a>_.throttle 方法源码</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 频率控制 返回函数连续调用时，func 执行频率限定为 次 / wait</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @param  &#123;function&#125;   func      传入函数</span></span><br><span class="line"><span class="comment"> * @param  &#123;number&#125;     wait      表示时间窗口的间隔</span></span><br><span class="line"><span class="comment"> * @param  &#123;object&#125;     options   如果想忽略开始边界上的调用，传入&#123;leading: false&#125;。</span></span><br><span class="line"><span class="comment"> *                                如果想忽略结尾边界上的调用，传入&#123;trailing: false&#125;</span></span><br><span class="line"><span class="comment"> * @return &#123;function&#125;             返回客户调用函数   </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">_.throttle = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> context, args, result;</span><br><span class="line">  <span class="keyword">var</span> timeout = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 上次执行时间点</span></span><br><span class="line">  <span class="keyword">var</span> previous = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (!options) options = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 延迟执行函数</span></span><br><span class="line">  <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 若设定了开始边界不执行选项，上次执行时间始终为0</span></span><br><span class="line">    previous = options.leading === <span class="literal">false</span> ? <span class="number">0</span> : _.now();</span><br><span class="line">    timeout = <span class="literal">null</span>;</span><br><span class="line">    result = func.apply(context, args);</span><br><span class="line">    <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> now = _.now();</span><br><span class="line">    <span class="comment">// 首次执行时，如果设定了开始边界不执行选项，将上次执行时间设定为当前时间。</span></span><br><span class="line">    <span class="keyword">if</span> (!previous &amp;&amp; options.leading === <span class="literal">false</span>) previous = now;</span><br><span class="line">    <span class="comment">// 延迟执行时间间隔</span></span><br><span class="line">    <span class="keyword">var</span> remaining = wait - (now - previous);</span><br><span class="line">    context = <span class="keyword">this</span>;</span><br><span class="line">    args = <span class="built_in">arguments</span>;</span><br><span class="line">    <span class="comment">// 延迟时间间隔remaining小于等于0，表示上次执行至此所间隔时间已经超过一个时间窗口</span></span><br><span class="line">    <span class="comment">// remaining大于时间窗口wait，表示客户端系统时间被调整过</span></span><br><span class="line">    <span class="keyword">if</span> (remaining &lt;= <span class="number">0</span> || remaining &gt; wait) &#123;</span><br><span class="line">      clearTimeout(timeout);</span><br><span class="line">      timeout = <span class="literal">null</span>;</span><br><span class="line">      previous = now;</span><br><span class="line">      result = func.apply(context, args);</span><br><span class="line">      <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 如果延迟执行不存在，且没有设定结尾边界不执行选项</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!timeout &amp;&amp; options.trailing !== <span class="literal">false</span>) &#123;</span><br><span class="line">      timeout = setTimeout(later, remaining);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="debounce-方法源码"><a href="#debounce-方法源码" class="headerlink" title="_.debounce 方法源码"></a>_.debounce 方法源码</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空闲控制 返回函数连续调用时，空闲时间必须大于或等于 wait，func 才会执行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param  &#123;function&#125; func        传入函数</span></span><br><span class="line"><span class="comment"> * @param  &#123;number&#125;   wait        表示时间窗口的间隔</span></span><br><span class="line"><span class="comment"> * @param  &#123;boolean&#125;  immediate   设置为ture时，调用触发于开始边界而不是结束边界</span></span><br><span class="line"><span class="comment"> * @return &#123;function&#125;             返回客户调用函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">_.debounce = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timeout, args, context, timestamp, result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 据上一次触发时间间隔</span></span><br><span class="line">    <span class="keyword">var</span> last = _.now() - timestamp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上次被包装函数被调用时间间隔last小于设定时间间隔wait</span></span><br><span class="line">    <span class="keyword">if</span> (last &lt; wait &amp;&amp; last &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      timeout = setTimeout(later, wait - last);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timeout = <span class="literal">null</span>;</span><br><span class="line">      <span class="comment">// 如果设定为immediate===true，因为开始边界已经调用过了此处无需调用</span></span><br><span class="line">      <span class="keyword">if</span> (!immediate) &#123;</span><br><span class="line">        result = func.apply(context, args);</span><br><span class="line">        <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    context = <span class="keyword">this</span>;</span><br><span class="line">    args = <span class="built_in">arguments</span>;</span><br><span class="line">    timestamp = _.now();</span><br><span class="line">    <span class="keyword">var</span> callNow = immediate &amp;&amp; !timeout;</span><br><span class="line">    <span class="comment">// 如果延时不存在，重新设定延时</span></span><br><span class="line">    <span class="keyword">if</span> (!timeout) timeout = setTimeout(later, wait);</span><br><span class="line">    <span class="keyword">if</span> (callNow) &#123;</span><br><span class="line">      result = func.apply(context, args);</span><br><span class="line">      context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://zhuanlan.zhihu.com/p/26054718" target="_blank" rel="noopener">js性能优化underscore throttle 与 debounce 节流</a><br><a href="https://blog.coding.net/blog/the-difference-between-throttle-and-debounce-in-underscorejs" target="_blank" rel="noopener">浅谈 Underscore.js 中 _.throttle 和 _.debounce 的差异</a><br><a href="https://github.com/lessfish/underscore-analysis/issues/20" target="_blank" rel="noopener">JavaScript 函数节流和函数去抖应用场景辨析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript 函数节流和函数去抖&lt;/p&gt;
    
    </summary>
    
    
      <category term="js" scheme="http://yoursite.com/tags/js/"/>
    
      <category term="性能" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>Web通讯(HTTP协议)</title>
    <link href="http://yoursite.com/2017/10/web-url/"/>
    <id>http://yoursite.com/2017/10/web-url/</id>
    <published>2017-10-29T08:11:00.000Z</published>
    <updated>2019-12-20T01:21:42.501Z</updated>
    
    <content type="html"><![CDATA[<p>记录学习Web通讯基础，URL是网络上的链接，这个链接就像一个地址，用来准确定位到某个资源；下面是有关URL的简单介绍和理解。</p><a id="more"></a><h2 id="URL是什么？"><a href="#URL是什么？" class="headerlink" title="URL是什么？"></a>URL是什么？</h2><p>URL又叫做<strong>统一资源定位符</strong>（<strong>U</strong>niform <strong>R</strong>esource <strong>L</strong>ovator），它支持多种协议：<strong>HTTP</strong>、<strong>FTP</strong>…</p><h3 id="URL的格式"><a href="#URL的格式" class="headerlink" title="URL的格式"></a>URL的格式</h3><p>URL是有标准的格式，所有的浏览器和Web服务器都遵循这个标准的格式，保障了我们使用的浏览器能够访问服务器里特定的资源。</p><p>URL的详细格式：<strong>schema://host[:port#]/path/…/[?query-string][#anchor]</strong></p><ol><li>schema：底层协议（例如：http，https，ftp）</li><li>host：服务器的域名或者IP地址</li><li>port：服务器端口（HTTP默认端口是80，可省略）</li><li>path：表示访问资源的路径</li><li>query-string：发送给http服务器的数据</li><li>anchor：锚点，通常表示在页面的特定位置</li></ol><hr><p>从上面我们知道了什么是URL，知道URL包含很多协议，其中HTTP就是我们Web使用的协议，下面内容讲解什么HTTP协议相关知识。</p><h2 id="HTTP是什么？"><a href="#HTTP是什么？" class="headerlink" title="HTTP是什么？"></a>HTTP是什么？</h2><p>HTTP又叫做<strong>超文本传输协议</strong>（<strong>H</strong>yper <strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol）,它是Web通讯最常用的协议。</p><p><strong>HTTP</strong>报文是是比较重要的内容，其中包含请求报文和响应报文。简单的来说，<strong>HTTP</strong>报文都由简单的三部分组成（起始行，头，主体）。<strong>HTTP</strong>协议中的请求和响应报文中必定包含<strong>HTTP</strong>首部（起始行，头），首部内容为客户端和服务器分别处理请求和响应提供所需要的信息。下来来看看请求和响应报文的内容。</p><h3 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">GET /sugrec?pre=1&amp;p=3 HTTP/1.1     ---请求行（Request Line）</span><br><span class="line">Host: www.baidu.com                ---头部（Headers）</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Accept: text/javascript, application/javascript, application/ecmascript, application/x-ecmascript, */*; q=0.01</span><br><span class="line">X-Requested-With: XMLHttpRequest</span><br><span class="line">User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36</span><br><span class="line">Referer: https://www.baidu.com/s?wd=%E9%94%9A&amp;rsv_spt=1</span><br><span class="line">Accept-Encoding: gzip, deflate, br</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Cookie: BIDUPSID=C4EC634634EE54FFA735244DAFA786D8; PSTM=1523352909; BD_UPN=123253; __cfduid=da802f70bcb5061a35bb3437e96873ab41542608259; BAIDUID=57224FD0460FA6A0918A6B0678BF848D:FG=1; MSA_WH=320_568; BDORZ=B490B5EBF6F3CD402E515D22BCDA1598; delPer=0; BD_CK_SAM=1; BD_HOME=1; BDRCVFR[feWj1Vr5u3D]=I67x6TjHwwYf0;</span><br><span class="line"></span><br><span class="line">----------------------------------------------</span><br><span class="line">|                                            |</span><br><span class="line">|                                            |</span><br><span class="line">|       数据体（Body）GET请求无此部分</span><br><span class="line">|                                            |</span><br><span class="line">|                                            |</span><br><span class="line">----------------------------------------------</span><br></pre></td></tr></table></figure><h3 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK ---状态行（Status Line）</span><br><span class="line">Content-Length: 404 ---消息报头</span><br><span class="line">Content-Type: text/plain; charset=UTF-8</span><br><span class="line">Date: Mon, 05 Aug 2019 02:31:02 GMT</span><br><span class="line"></span><br><span class="line">----------------------------------------------</span><br><span class="line">|                                            |</span><br><span class="line">|                                            |</span><br><span class="line">|                  响应正文</span><br><span class="line">|                                            |</span><br><span class="line">|                                            |</span><br><span class="line">----------------------------------------------</span><br></pre></td></tr></table></figure><h3 id="相应报文状态码"><a href="#相应报文状态码" class="headerlink" title="相应报文状态码"></a>相应报文状态码</h3><table><thead><tr><th></th><th>类别</th><th>解释</th></tr></thead><tbody><tr><td>1XX</td><td>信息性状态码</td><td>接受的请求正在处理</td></tr><tr><td>2XX</td><td>成功状态码</td><td>请求正常处理完成</td></tr><tr><td>3XX</td><td>重定向状态码</td><td>需要进行附加操作</td></tr><tr><td>4XX</td><td>客户端错误状态码</td><td>服务器无法处理请求</td></tr><tr><td>5XX</td><td>服务器错误状态码</td><td>服务器处理请求出错</td></tr></tbody></table><p><strong>状态码详细解析</strong></p><ul><li><strong>200</strong>：表示从客户端发来的请求在服务器被正常处理。</li><li><strong>204</strong>：表示服务器接收的请求已成功处理，但没有数据返回。</li><li><strong>206</strong>：表示客户端进行了范围请求，而服务器成功执行了这部分的请求。响应报文中包含由<strong>Content-Range</strong>指定范围的实体内容。</li><li><strong>301</strong>：永久重定向（告知浏览器更新书签引用）。</li><li><strong>302</strong>：临时性重定向。表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问。</li><li><strong>303</strong>：表示由于请求对应的资源存在着另一个URI，应使用GET方式定向获取请求的资源。（303状态码和302状态码有着相同的功能，但303状态码明确表示客户端应当采用GET方式获取资源。）</li><li><strong>304</strong>：表示客户端发送了一个带条件的GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变。（服务器资源未变化）</li><li><strong>400</strong>：表示请求报文中存在语法错误。</li><li><strong>401</strong>：表示发送的请求需要有通过HTTP认证的认证信息。另外如果之前已进行过一次请求，则表示用户认证失败。</li><li><strong>403</strong>：表示对请求资源的访问被服务器拒绝了。</li><li><strong>404</strong>：表示服务器上无法找到请求的资源。</li><li><strong>500</strong>：表示服务器在执行请求时发生了错误。</li><li><strong>503</strong>：表示服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li></ul><h3 id="HTTP首部字段-请求头部、消息报头）"><a href="#HTTP首部字段-请求头部、消息报头）" class="headerlink" title="HTTP首部字段(请求头部、消息报头）"></a>HTTP首部字段(请求头部、消息报头）</h3><p>HTTP首部字段是构成HTTP报文的重要要素之一。无论是请求还是响应都会使用首部字段，它能起到传递额外重要信息的作用。</p><h4 id="四种HTTP首部字段类型。"><a href="#四种HTTP首部字段类型。" class="headerlink" title="四种HTTP首部字段类型。"></a>四种HTTP首部字段类型。</h4><h5 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h5><blockquote><p>请求报文和响应报文都会使用的首部字段。</p></blockquote><h5 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h5><blockquote><p>从客户端向服务器发送请求报文时使用的首部，补充了请求的附加内容、客户端信息、响应内容相关优先级等信息。</p></blockquote><h5 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h5><blockquote><p>从服务器向客户端返回响应报文时使用的首部，补充了响应的附加内容，也会要求客户端附加额外的内容信息。</p></blockquote><h5 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h5><blockquote><p>针对请求报文和响应报文的实体部分使用的首部。补充了资源内容更新时间等与实体有关的信息。</p></blockquote><p>由于字段内容多且复杂，具体字段细节不在细说。</p><p>补充：</p><ol><li>get请求数据体是没有的，post请求发送的数据就会在数据体里。</li><li><strong>请求头部和数据体</strong>之间会有一行空行；<strong>消息报头和响应正文</strong>之间也会有一行空行；</li></ol><p>请求头部有两个比较重要的字段我们可以了解一下。</p><ol><li><strong>Cookie</strong>是用户的凭证（jwt的作用和Cookie相似，常用于登录身份校验）。</li><li><strong>Referer</strong>：主要作用是告知服务器该请求的来源（浏览器自动加上）所以可以用于统计流量的来源，也可以用于判断来源是否合法（防止盗链、防止CSRF漏洞）。</li></ol><hr><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>《图解HTTP》<br>《Web白帽子》</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录学习Web通讯基础，URL是网络上的链接，这个链接就像一个地址，用来准确定位到某个资源；下面是有关URL的简单介绍和理解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Web" scheme="http://yoursite.com/tags/Web/"/>
    
      <category term="URL" scheme="http://yoursite.com/tags/URL/"/>
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTMl5的sessionStorage和localStorage</title>
    <link href="http://yoursite.com/2017/07/HTML5-storage/"/>
    <id>http://yoursite.com/2017/07/HTML5-storage/</id>
    <published>2017-07-20T11:27:00.000Z</published>
    <updated>2019-08-05T01:53:11.413Z</updated>
    
    <content type="html"><![CDATA[<p>说说<code>LocalStorage</code>与<code>SessionStorage</code>的关系、以及<code>Cookie</code>与它们的区别。 </p><a id="more"></a><h3 id="sessionStorage和localStorage的关系"><a href="#sessionStorage和localStorage的关系" class="headerlink" title="sessionStorage和localStorage的关系"></a>sessionStorage和localStorage的关系</h3><p>Html5中的<code>Web Storage</code>包括了两种存储方式：<code>sessionStorage 和 localStorage</code>。</p><blockquote><ul><li><code>sessionStorage</code>用于本地存储一个会话<code>（session）</code>中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此<code>sessionStorage</code>不是一种持久化的本地存储，仅仅是会话级别的存储。</li><li>而<code>localStorage</code>用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</li></ul></blockquote><h3 id="Cookie的概念"><a href="#Cookie的概念" class="headerlink" title="Cookie的概念"></a>Cookie的概念</h3><blockquote><p><code>Cookie</code>是小甜饼的意思。顾名思义，<code>cookie</code> 确实非常小，它的大小限制为4KB左右，是网景公司的前雇员 Lou Montulli 在1993年3月的发明。它的主要用途有保存登录信息，比如你登录某个网站市场可以看到“记住密码”，这通常就是通过在<code>Cookie</code>中存入一段辨别用户身份的数据来实现的。</p></blockquote><h3 id="三者的区别"><a href="#三者的区别" class="headerlink" title="三者的区别"></a>三者的区别</h3><ol><li><strong>数据的生命周期</strong><br><code>Cookie</code>：一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效。<br><code>localStorage</code>：除非被清除，否则永久保存。<br><code>sessionStorage</code>：仅在当前会话下有效，关闭页面或浏览器后被清除。</li><li><strong>存放数据大小</strong><br><code>Cookie</code>：4KB左右。<br><code>localStorage 和 sessionStorage</code>：一般为5MB。</li><li><strong>与服务器端通信</strong><br><code>Cookie</code>：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题。<br><code>localStorage 和 sessionStorage</code>：仅在客户端（即浏览器）中保存，不参与和服务器的通信。</li></ol><p><strong>总的来说</strong>：<br><strong><code>Web Storage</code>的概念和<code>cookie</code>相似，区别是它是为了更大容量存储设计的。<br><code>Cookie</code>的大小是受限的，并且每次你请求一个新的页面的时候<code>Cookie</code>都会被发送过去，这样无形中浪费了带宽。<br>另外<code>cookie</code>还需要指定作用域，不可以跨域调用。<br>但是<code>Cookie</code>也是不可以或缺的：<code>Cookie</code>的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而<code>Web Storage</code>仅仅是为了在本地“存储”数据而生。</strong></p><h3 id="localStorage-和-sessionStorage的方法"><a href="#localStorage-和-sessionStorage的方法" class="headerlink" title="localStorage 和 sessionStorage的方法"></a>localStorage 和 sessionStorage的方法</h3><h5 id="1-setItem存储value"><a href="#1-setItem存储value" class="headerlink" title="1. setItem存储value"></a>1. <strong>setItem存储value</strong></h5><p>用途：将value存储到key字段<br>用法：.setItem( key, value)<br>代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage.setItem(<span class="string">"key"</span>, <span class="string">"value1"</span>)</span><br><span class="line">localStorage.setItem(<span class="string">"site"</span>, <span class="string">"value2"</span>);</span><br></pre></td></tr></table></figure><h5 id="2-getItem获取value"><a href="#2-getItem获取value" class="headerlink" title="2. getItem获取value"></a>2. <strong>getItem获取value</strong></h5><p>用途：获取指定key本地存储的值<br>用法：.getItem(key)<br>代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> value = sessionStorage.getItem(<span class="string">"key"</span>)</span><br><span class="line"><span class="keyword">let</span> site = localStorage.getItem(<span class="string">"site"</span>)</span><br></pre></td></tr></table></figure><h5 id="3-removeItem删除key"><a href="#3-removeItem删除key" class="headerlink" title="3. removeItem删除key"></a>3. <strong>removeItem删除key</strong></h5><p>用途：删除指定key本地存储的值<br>用法：.removeItem(key)<br>代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage.removeItem(<span class="string">"key"</span>)</span><br><span class="line">localStorage.removeItem(<span class="string">"site"</span>)</span><br></pre></td></tr></table></figure><h5 id="4-clear清除所有的key-value"><a href="#4-clear清除所有的key-value" class="headerlink" title="4. clear清除所有的key/value"></a>4. <strong>clear清除所有的key/value</strong></h5><p>用途：清除所有的key/value<br>用法：.clear()<br>代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage.clear()</span><br><span class="line">localStorage.clear()</span><br></pre></td></tr></table></figure><h5 id="5-其他操作方法：-操作和"><a href="#5-其他操作方法：-操作和" class="headerlink" title="5. 其他操作方法：.操作和[]"></a>5. <strong>其他操作方法：<code>.</code>操作和<code>[]</code></strong></h5><p>web Storage不但可以用自身的<code>setItem,getItem</code>等方便存取，也可以像普通对象一样用点<code>(.)</code>操作符，及<code>[]</code>的方式进行数据存储，像如下的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> storage = <span class="built_in">window</span>.localStorage</span><br><span class="line">storage.key1 = <span class="string">"value1"</span></span><br><span class="line">storage[<span class="string">"key2"</span>] = <span class="string">"value2"</span></span><br><span class="line"><span class="built_in">console</span>.log(storage.key1)  <span class="comment">//  value1</span></span><br><span class="line"><span class="built_in">console</span>.log(storage[<span class="string">"key2"</span>])  <span class="comment">//  value2</span></span><br></pre></td></tr></table></figure><h5 id="6-localStorage-和-sessionStorage的遍历"><a href="#6-localStorage-和-sessionStorage的遍历" class="headerlink" title="6. localStorage 和 sessionStorage的遍历"></a>6. <strong>localStorage 和 sessionStorage的遍历</strong></h5><p><code>sessionStorage 和 localStorage</code>提供的<code>key() 和 length</code>可以方便的实现存储的数据遍历<br>代码示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> storage = <span class="built_in">window</span>.localStorage</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>;i &lt; storage.length;i++)&#123;</span><br><span class="line">  <span class="keyword">let</span> key = storage.key(i)</span><br><span class="line">  <span class="keyword">let</span> value = storage.getItem(key)     </span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">"="</span> + value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-storage事件"><a href="#7-storage事件" class="headerlink" title="7. storage事件"></a>7. <strong>storage事件</strong></h5><p><code>storage</code>还提供了<code>storage</code>事件，当<code>键值</code>改变或者<code>clear</code>的时候，就可以触发<code>storage</code>事件，如下面的代码就添加了一个storage事件改变的监听：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.addEventListener)&#123;</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">"storage"</span>,handle_storage,<span class="literal">false</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">window</span>.attachEvent)&#123;</span><br><span class="line">  <span class="built_in">window</span>.attachEvent(<span class="string">"onstorage"</span>,handle_storage)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle_storage</span>(<span class="params">ev</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> ev = ev || <span class="built_in">window</span>.ev </span><br><span class="line">  <span class="comment">//  其中storage事件有以下属性</span></span><br><span class="line">  ev.key  <span class="comment">//  存储store的key名。</span></span><br><span class="line">  ev.oldValue  <span class="comment">//  更新前的值。如果该键为新增加，则这个属性为null。 </span></span><br><span class="line">  ev.newValue  <span class="comment">//  更新后的值，如果该键被删除，则这个属性为null。</span></span><br><span class="line">  ev.url  <span class="comment">//  原始触发storage事件的那个网页的网址。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;说说&lt;code&gt;LocalStorage&lt;/code&gt;与&lt;code&gt;SessionStorage&lt;/code&gt;的关系、以及&lt;code&gt;Cookie&lt;/code&gt;与它们的区别。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="html5" scheme="http://yoursite.com/tags/html5/"/>
    
  </entry>
  
  <entry>
    <title>for...in和for...of循环的区别</title>
    <link href="http://yoursite.com/2017/07/for-in-and-for-of/"/>
    <id>http://yoursite.com/2017/07/for-in-and-for-of/</id>
    <published>2017-07-10T06:26:00.000Z</published>
    <updated>2019-08-05T01:27:19.938Z</updated>
    
    <content type="html"><![CDATA[<p>简单了解下…..</p><a id="more"></a><h3 id="for-in测试"><a href="#for-in测试" class="headerlink" title="for in测试"></a><code>for in</code>测试</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]</span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>])</span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'a'</span>,<span class="number">1</span>],[<span class="string">'b'</span>,<span class="number">2</span>],[<span class="string">'c'</span>,<span class="number">3</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment">//  遍历数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> x <span class="keyword">in</span> a)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x)  <span class="comment">//  得到的是下标 0 1 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> x <span class="keyword">in</span> s)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x)  <span class="comment">//  不起作用，无法遍历Set</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> x <span class="keyword">in</span> m)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x)  <span class="comment">//  不起作用，无法遍历Map</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for-of测试"><a href="#for-of测试" class="headerlink" title="for of测试"></a><code>for of</code>测试</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]</span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'c'</span>])</span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'a'</span>,<span class="number">1</span>],[<span class="string">'b'</span>,<span class="number">2</span>],[<span class="string">'c'</span>,<span class="number">3</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment">//  遍历数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> x <span class="keyword">of</span> a)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x)  <span class="comment">//  得到的是值 a b c</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> x <span class="keyword">of</span> s)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x)  <span class="comment">//  得到的是值 a b c</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [key,value] <span class="keyword">of</span> m)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)  <span class="comment">//  得到的是key值 a b c</span></span><br><span class="line">  <span class="built_in">console</span>.log(value)  <span class="comment">//  得到的是value值 1 2 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for-in的问题"><a href="#for-in的问题" class="headerlink" title="for in的问题"></a><code>for in</code>的问题</h3><p><strong><code>for in</code>遍历的实际上是对象的属性名称。一个<code>Array</code>数组也是一个对象，数组中的每个元素的索引被视为属性名称，所以我们可以看到使用<code>for...in</code>循环<code>Array</code>数组时，拿到的其实是每个元素的索引。</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]</span><br><span class="line">a.name = <span class="string">'wpnl'</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> x <span class="keyword">in</span> a)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x)  <span class="comment">//  0 1 2 name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，当我们为a多手动添加一个属性<code>name</code>的时候，<code>for...in</code>循环会把name属性也包括在内，而<code>Array</code>的<code>length</code>属性却不包括在内。</p><p><code>for...of</code>循环则不存在上述的问题，它只循环集合本身的元素。这就是为什么引入<code>for...of</code>循环。所以<code>for...of</code>循环功能比较好，推荐使用</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>for-of</code>循环的几个特征</p><ul><li>这是最简洁、最直接的遍历数组元素的语法。</li><li>这个方法避开了<code>for-in</code>循环的所有缺陷。</li><li>与<code>forEach</code>不同的是，它可以正确响应<code>break、continue 和 return</code>语句。</li><li>其不仅可以遍历数组，还可以遍历类数组对象和其他可迭代对象。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单了解下…..&lt;/p&gt;
    
    </summary>
    
    
      <category term="javaScript" scheme="http://yoursite.com/tags/javaScript/"/>
    
  </entry>
  
  <entry>
    <title>移动端meta通用设置</title>
    <link href="http://yoursite.com/2017/06/viewport-meta/"/>
    <id>http://yoursite.com/2017/06/viewport-meta/</id>
    <published>2017-06-29T08:11:00.000Z</published>
    <updated>2020-02-08T15:50:53.688Z</updated>
    
    <content type="html"><![CDATA[<p>关于移动端 <code>&lt;meta&gt;</code> 的一些配置。</p><a id="more"></a><p>一个常用的针对移动网页优化过的页面的 viewport meta 标签大致如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"</span> <span class="attr">name</span>=<span class="string">"viewport"</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>width</code>：控制 viewport 的大小,如 device-width 为设备的宽度。</li><li><code>height</code>：和 width 相对应，指定高度。</li><li><code>initial-scale</code>：初始缩放比例，也即是当页面第一次 load 的时候缩放比例。</li><li><code>maximum-scale</code>：允许用户缩放到的最大比例。</li><li><code>minimum-scale</code>：允许用户缩放到的最小比例。</li><li><code>user-scalable</code>：用户是否可以手动缩放。</li></ul><hr><p>下面是移动端 <code>&lt;meta&gt;</code> 的通用设置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 避免IE使用兼容模式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge,chrome=1"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 启用360浏览器的极速模式(webkit) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"renderer"</span> <span class="attr">content</span>=<span class="string">"webkit"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 关键字描述 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"keywords"</span> <span class="attr">content</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"HandheldFriendly"</span> <span class="attr">content</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 删除苹果默认的工具栏和菜单栏 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-mobile-web-app-capable"</span> <span class="attr">content</span>=<span class="string">"yes"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 设置苹果工具栏颜色 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"apple-mobile-web-app-status-bar-style"</span> <span class="attr">content</span>=<span class="string">"black"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 忽略页面中的数字识别为电话，忽略email识别 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"format-detection"</span> <span class="attr">content</span>=<span class="string">"telphone=no, email=no"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- uc强制竖屏 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"screen-orientation"</span> <span class="attr">content</span>=<span class="string">"portrait"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- QQ强制竖屏 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"x5-orientation"</span> <span class="attr">content</span>=<span class="string">"portrait"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- UC强制全屏 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"full-screen"</span> <span class="attr">content</span>=<span class="string">"yes"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- QQ强制全屏 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"x5-fullscreen"</span> <span class="attr">content</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- UC应用模式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"browsermode"</span> <span class="attr">content</span>=<span class="string">"application"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- QQ应用模式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"x5-page-mode"</span> <span class="attr">content</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- windows phone 点击无高光 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"msapplication-tap-highlight"</span> <span class="attr">content</span>=<span class="string">"no"</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于移动端 &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; 的一些配置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="meta" scheme="http://yoursite.com/tags/meta/"/>
    
  </entry>
  
</feed>
